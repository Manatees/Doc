# 序列化

对象序列化是 Java 的一个框架，用来将对象编码成字节流（序列化），并从字节流编码中重新构建对象（反序列化）。一旦对象被序列化后，它的编码就可以从一台正在运行的虚拟机被传递至另一台虚拟机上，或者被存储到磁盘上，代后续反序列化时使用。本章主要关注序列化的风险，以及如何将风险降到最低。



## 85. 其他方法优先于 Java 序列化

1997 年， Java 新增了序列化时，就被认为是有风险的。这种方法已经作为研究语言( Modula-3 ）做过尝试但在生产语言中还从未试过。虽然分布式对象使程序员这部分的工作简化了，为之付出的代价却是不可见的构造器，还有API 和实现之间模糊的界限，而且在代码的正确性、性能、安全性、维护性方面都有潜在的问题。拥护者们相信利大于弊，但是历史证明事实正好相反。

在本书第 2 版中谈到的安全性问题，事实证明每一点滴都可能酿成大祸。2000 年之前广泛讨论的安全漏洞，十年之后酿成了严重的攻击事件（ exploit ），其中著名的有2016 年11月发生在旧金山市政交通局（ SFMTA Muni ）的黑客勒索软件攻击事件，导致整个收费系统整整瘫痪了两天［Gallagher! 6 ］ 。

序列化的根本问题在于，其攻击面（ attack surface ）过于庞大，无法进行防护，并且它还在不断地扩大：对象图是通过在 `ObjectIputStream` 上调用`readObject` 方法进行反序列化的。这个方法其实是个神奇的构造器，它可以将类路径上几乎任何类型的对象都实例化，只要该类型实现了`Serializable` 接口。在反序列化字节流的过程中，该方法可以执行以上任意类型的代码，因此所有这些类型的代码都是攻击面的一部分。

攻击面包括 Java 平台类库中的类、第三方类库如 Apache Commons Collections 中的类，以及应用本身的类。即使遵守所有相关的最佳实践，成功地编写了无懈可击的可序列化类，这个应用也依然是有漏洞的。引用CERT （计算机安全应急响应组）协调中心技术经理Robert Seacord 的话说：

> Java 反序列化是一个明显存在的风险，它不仅被应用直接广泛使用，也被Java 子系统如RMI （远程方法调用）、JMX ( Java 管理扩展）和JMS ( Java 消息系统）等大量地间接使用。将不被信任的流进行反序列化，可能导致远程代码执行（ Remote Code Execution, RCE ）、拒绝服务（ Denial-of-Service, DoS ），以
> 及一系列其他的攻击。即使应用本身没有做错任何事情，也可能受到这些攻击[Seacord I 7 ］。

攻击者和安全研究员都在研究Java 类库和常用的第三方类库中可序列化的类型，寻找在进行潜在危险活动的反序列化期间被调用的方法。这些方法被称作指令片段 (gadget)。 多个指令片段可以一起使用，形成一个指令片段链 ( gadget chain ) 。随着时间的推移，我们发现指令片段链的功能十分强大，允许攻击者在底层硬件中执行任意的本机代码，唯一的机会就是为反序列化提交精心编写的字节流。这正是发生在SFMTA Muni 的攻击。这个攻击不是孤立的，还会有其他的攻击，并且会越来越多。

如果不使用任何指令片段，对于需要长时间进行反序列化的简短字节流，只要引发反序列化，就可以轻松地展开一次拒绝服务攻击。这样的字节流被称作反序列化炸弹( deserialization bomb) [Svoboda I 6 ］ 。下面举一个来自Wouter Coekaerts 的范例，它只用了散列集和一个字符串［Coekaerts 15]:

```java
// Deserializaion bomb - deserializaing this stream takes forever
static byte[] bomb() {
    Set<Object> root = new HashSet<>();
    Set<Object> s1 = root;
    Set<Object> s2 = new HashSet<>();
    for (int i=0; i<100; i++) {
        Set<Object> t1 = new HashSet<>();
        Set<Object> t2 = new HashSet<>();
        t1.add("foo"); // Make t1 unequal to t2
        s1.add(t1);
        s2.add(t1);
        s1 = t1;
        s2 = t2;
    }
    return serialize(root); // Method omitted for brevity
}
```

对象图中包含了201 个 `HashSet` 实例，其中每个实例都包含3 个或3 个以下对象引用。整个字节流的长度为5744 个字节，但在反序列化之前，总长度会呈爆炸式增长。问题在于，反序列化 `HashSet` 实例需要计算其元素的散列码。根散列集合中的这 2 个元素，就是包含 2 个散列集元素的散列集本身，其中每个都包含 2 个散列集元素，等等，一共有 100 级之深。因此，反序列化集合会导致 `hashCode` 方法被调用超过2<sup>100</sup> 次。反序列化花费的时间是无限的，而且它从不提示是什么东西出了错。它几乎不产生任何对象，堆枝深度也是有限的。

我们怎么做才能预防这些问题呢？每当反序列化一个不信任的字节流时，自己就要试着去攻击它。避免序列化攻击的最佳方式是永远不要反序列化任何东西。引用1983 年电影《War Games》中Joshua 的话：“获胜的唯一方法就是压根儿不参与比赛。” 在新编写的任何新系统中都没有理由再使用Java 序列化。为了避免Java 序列化的诸多风险，还有许多其他机制可以完成对象和字节序列之间的转化，它们同时还能带来很多便利，诸如跨平台支持、高性能、一个大型的工具生态系统，以及一个广阔的专家社区。本书把这些机制作称跨平台的结构化数据表示法（ cross-platform structured-data representation ） 。虽然在其他地方有时候会把它们称作序列化系统，但本书不那样用，避免与Java 序列化造成混淆。

这些表示法的共同点是，它们都远比 Java 序列化要简单得多。它们不支持任意对象图的自动序列化和反序列化。而是支持包含属性/值对的简单的结构化数据对象。它们只支持一些基本类型和数组数据类型。事实证明，这个抽象虽然简单，却足以构建功能极其强大的分布式系统，同时又简单得足以避免自Java 序列化出现以来就一直造成困扰的那些重大问题。

我们怎么做才能预防这些问题呢？每当反序列化一个不信任的字节流时，自己就要试
着去攻击它。避免序列化攻击的最佳方式是永远不要反序列化任何东西。引用1983 年电影
《WarGam巳s 》中Joshua 的话：“获胜的唯一方法就是压根儿不参与比赛。” 在新编写的任何
新系统中都没有理由再使用Java 序列化。为了避免Java 序列化的诸多风险，还有许多其他
机制可以完成对象和字节序列之间的转化，它们同时还能带来很多便利，诸如跨平台支持、
高性能、一个大型的工具生态系统，以及一个广阔的专家社区。本书把这些机制作称跨平台
的结构化数据表示法（ cross-platform structured-data representation ） 。虽然在其他地方有时候
会把它们称作序列化系统，但本书不那样用，避免与Java 序列化造成混淆。
这些表示法的共同点是，它们都远比Java 序列化要简单得多。它们不支持任意对象图
的自动序列化和反序列化。而是支持包含属性／ 值对的简单的结构化数据对象。它们只支持
一些基本类型和数组数据类型。事实证明，这个抽象虽然简单，却足以构建功能极其强大
的分布式系统，同时又简单得足以避免自Java 序列化出现以来就一直造成困扰的那些重大
问题。
最前沿的跨平台结构化数据表示法是JSON [JSON］和Protocol Buffi巳rs ，也称作protobuf [ProtobufJ 。JSON 是Douglas Crockford 为浏览器一服务器之间的通信设计的， Protocol Buffers 是Google 为了在服务器之间保存和交换结构化数据设计的。尽管有时候这些表示法也被称 作中性语言（ language - neutral), JSON 起初却是为JavaScript 开发的， protobuf 是为C++ 开发的，这两者都保持着设计初衷的痕迹。

JSON 和 protobuf 之间最明显的区别在于， JSON 是基于文本的，人类可以阅读，而 protobuf 是二进制的，从根本上来说更有效； JSON 纯粹就是一个数据表示法，而protobuf 则提供模式（类型），建立文挡，强制正确的用法。虽然 protobuf 比 JSON 更加有效，但 JSON 对于基于文本的表示法却非常高效。protobuf 虽然是一个二进制表示法，但它提供了可以替代的另一种文本表示法（ pbtxt ），当人类需要读懂它的时候；可以使用。

如果无法完全避免Java 序列化，或许是因为需要在Java 序列化的遗留系统环境中工作，下一步最好永远不要反序列化不被信任的数据。尤其是永远不应该接受来自不信任资源的 RMI 通信。Java 官方安全编码指导方针中提出：“对不信任数据的反序列化，从本质上来说是危险的，应该予以避免。”这个句子在文中用红色的字体突出显示，在介绍这一点的整个文档中，只有这一句话［Java-secure］ 。

如果无法避免序列化，又不能绝对确保被反序列化的数据的安全性，就应利用Java 9 中新增的对象反序列化过滤（ object deserialization filtering ），这一功能也已经移植到了Java 较早的版本（ `java.io.ObjectinputFilter` ） 。它可以在数据流被反序列化之前，为它们定义一个过滤器。它可以操作类的粒度，允许接受或者拒绝某些类。默认接受类，同时拒绝可能存在危险的黑名单（ blacklisting ）；默认拒绝类，同时接受假定安全的白名单（ whit巳listing ） 。白名单优于黑名单，因为黑名单只能抵御已知的攻击。有一个工具叫作SWAT (Serial Whitelist Application Trainer ），它可以自动地替应用准备好自名单[Schneider 16 ］ 。过滤设施也能帮助你避免过度使用内存，并广泛深入对象图，但无法防御上面提到过的序列化炸弹。

遗憾的是，序列化在Java 生态系统中仍然十分普遍。如果在维护的系统是基于Java 序列化的，一定要认真考虑将它迁移到跨平台的结构化数据表示法，尽管这项工作费时费力。现实中，可能会发现仍然需要编写或者维护可序列化的类。要编写出正确、安全和高效的序列化类，需要加倍小心。本章剩下的内容将针对何时以及如何做到上述要求提出专业的建议。

总而言之，序列化是很危险的，应该予以避免。如果是重新设计一个系统，一定要用跨平台的结构化数据表示法代替，如 JSON 或者protobuf。不要反序列化不被信任的数据。如果必须这么做，就要使用对象的反序列化过滤，但要注意的是，它并不能确保阻止所有的攻击。不要编写可序列化的类。如果必须这么做一定要倍加小心地进行试验。



## 86. 谨慎地实现 Serializable 接口

要想使一个类的实例可被序列化，非常简单，只要在它的声明中加入 `implements Serializable` 字样即可。正因为太容易了，所以普遍存在这样一种误解，认为程序员毫不费力就可以实现序列化。而实际的情形要复杂得多。虽然使一个类可被序列化的直接开销非常低，甚至可以忽略不计，但是为了序列化而付出的长期开销往往是相当高的。

实现 `Serializable` 接口而付出的最大代价是，**一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性**。如果一个类实现了`Serializable` 接口，它的字节流编码（或者说序列化形式）就变成了它的导出的API 的一部分。一旦这个类被广泛使用，往往必须永远支持这种序列化形式，就好像你必须要支持导出的 API 的所有其他部分一样。如果不努力设计一种自定义的序列化形式（ custom serialized form ），而仅仅接受了默认的序列化形式，这种序列化形式将被永远地束缚在该类最初的内部表示法上。换句话说， 如果接受了默认的序列化形式，这个类中私有的和包级私有的实例域将都变成导出的API 的一部分，这不符合“最低限度地访问域”的实践准则（详见第15 条），从而它就失去了作为信息隐藏工具的有效性。

如果接受了默认的序列化形式，并且以后又要改变这个类的内部表示法，则结果可能导致序列化形式的不兼容。客户端程序企图用这个类的旧版本来序列化一个类，然后用新版本进行反序列化，结果将导致程序失败。反之亦然。在改变内部表示法的同时仍然维持原来的序列化形式（使用 `ObjectOutputStream.putFields` 和 `ObjectinputStream.readFields` ），这也是可能的，但是做起来比较困难，并且会在源代码中留下一些明显的隐患。因此，应该仔细地设计一种高质量的序列化形式，并且在很长时间内都愿意使用这种形式（详见第87 条和第90 条） 。这样做将会增加开发的初始成本，但这是值得的。设计良好的序列化形式也许会给类的演变带来限制；但是设计不好的序列化形式则可能会使类根本无法演变。

序列化会使类的演变受到限制，这种限制的一个例子与流的唯一标识符（ stream unique identifier ）有关，通常称它为序列版本UID ( serial version UID ）。每个可序列化的类都有一个唯一标识号与它相关联。如果你没有在一个名为 `serialVersionUID` 的私有静态 final 的long 域中显式地指定该标识号，系统就会对这个类的结构运用一个加密的散列函数( SHA-1 ），从而在运行时自动产生该标识号。这个自动产生的值会受到类名称、它所实现的接口的名称，以及所有公有的和受保护的成员的名称所影响。如果你通过任何方式改变了这些信息，比如，增加了一个不是很重要的工具方法，自动产生的序列版本UID 也会发生变化。因此，如果你没有声明一个显式的序列版本UID ，兼容性将会遭到破坏，在运行时导致 `InvalidClassException` 异常。

**实现 `Serializable` 的第二个代价是，它增加了出现Bug 和安全漏洞的可能性（详见第85 条）** 。通常情况下，对象是利用构造器来创建的；序列化机制是一种语言之外的对象创建机制（ extralinguistic mechanism ） 。无论你是接受了默认的行为，还是覆盖了默认的行为，反序列化机制（ deserialization ）都是一个“隐藏的构造器”，具备与其他构造器相同的特点。因为反序列化机制中没有显式的构造器，所以你很容易忘记要保证： 反序列化过程必须也要保证所有“由真正的构造器建立起来的约束关系”，并且不允许攻击者访问正在构造
过程中的对象的内部信息。依靠默认的反序列化机制，很容易使对象的约束关系遭到破坏，以及遭受到非法访问（见第88 条） 。

**实现 `Serializable` 的第三个代价是，随着类发行新的版本，相关的测试负担也会增加**。当一个可序列化的类被修订的时候，很重要的一点是，要检查是否可以“在新版本中序列化一个实例，然后在旧版本中反序列化”，反之亦然。因此，测试所需要的工作量与“可序列化的类的数量和发行版本号”的乘积成正比，这个乘积可能会非常大。你必须既要确保“序列化－反序列化”过程成功，也要确保结果产生的对象真正是原始对象的复制品。如果在最初编写一个类的时候，就精心设计了自定义的序列化形式，测试的要求就可以有所降低。

**实现 `Serializable` 接口并不是一个很轻松就可以做出的决定**。如果一个类将要加入到某个框架中，并且该框架依赖于序列化来实现对象传输或者持久化，对于这个类来说，实现 `Serializable`  接口就非常有必要。更进一步来看，如果这个类要成为另一个类的一个组件，并且后者必须实现 `Serializable` 接口，若前者也实现了 `Serializable` 接口，它就会更易于被后者使用。然而，有许多实际的开销都与实现 `Serializable` 接口有关。每当你实现一个类的时候，都需要权衡一下所付出的代价和带来的好处。根据经验，如 `BigInteger` 和`Instant` 等值类应该实现 `Serializable` 接口，大多数的集合类也应该如此。代表活动实体的类，比如线程池（ thread pool ）， 一般不应该实现 `Serializable` 接口。

**为了继承而设计的类（详见第19 条）应该尽可能少地去实现 `Serializable` 接口，用户的接口也应该尽可能少继承 `Serializable` 接口**。如果违反了这条规则，扩展这个类或者实现这个接口的程序员就会背上沉重的负担。然而在某些情况下违反这条规则却是合适的。例如，如果一个类或者接口存在的目的主要是为了参与到某个框架中，该框架要求所有的参与者都必须实现 `Serializable` 接口，那么，对于这个类或者接口来说，实现或者扩展 `Serializable` 接口就是非常有意义的。

在为了继承而设计的类中，真正实现了 `Serializable` 接口的有 `Throwable` 类和 `Component` 类。因为`Throwable` 类实现了`Serializable` 接口，所以RMI 的异常可以从服务器端传到客户端。`Component` 类实现了 `Serializable` 接口，因此GUI 可以被发送、保存和恢复，但是即使在Swing 和AWT 的鼎盛时间，这个机制在实践中也鲜被使用。

如果实现了一个带有实例域的类，它是可序列化和可扩展的，就应该担心以下几个风险。如果类的实例域值有一些约束条件，重要的是防止子类覆盖 `finalize` 方法，类只要通过覆盖 `finalize` 并把它声明为 final 便可以完成这个任务。否则，类就很容易受到终结器攻击（ finalizer attack ），详见第8 条。最后，如果类有限制条件，当类的实例域被初始化成它们的默认值（整数类型为0, boolean 为false ， 对象引用类型为null ）时，就会违背这些约束条件，这时候就必须给这个类添加 `readObjectNoData` 方法：

```java
// readObjectNoData for stateful extendable serializable classes
private void readObjectNoData() throws InvalidObjectException {
    throw new InvalidObjectException("Stream data required");
}
```

Java 4 版本就增加了这个 `readObjectNoData` 方法，还包含了一些冷僻的用例，包括给现有的可序列化类添加可序列化的超类［Serialization, 3 . 5 ］ 。
有一条告诫与“不要实现 `Serializable` 接口”有关。如果一个专门为了继承而设计的类不是可序列化的，那么想要编写出可序列化的子类就特别费力。这种类正常的反序列化就要求超类得有一个可访问的无参构造器［Serialization, 1.1 O ］ 。如果没有提供这样的无参构造器，子类就会被迫使用序列化代理模式（serialization proxy pattern），详见第90 条。

**内部类（详见第24 条）不应该实现 `Serializable` 接口**。它们使用编译器产生的合成域( synthetic field ）来保存指向外围实例（ enclosing instance ）的引用，以及保存来自外围作用域的局部变量的值。“这些域如何对应到类定义中”并没有明确的规定，就好像没有指定匿名类和局部类的名称一样。因此，内部类的默认序列化形式是定义不清楚的。然而，静态成员类（ static member class ）却可以实现 `Serializable` 接口。

简而言之，千万不要认为实现 `Serializable` 接口会很容易。除非一个类只在受保护的环境下使用，在这里版本之间永远不会交互，服务器永远不会暴露给不可信任的数据，否则，实现 `Serializable` 接口就是个很严肃的承诺，必须认真对待。如果一个类允许继承， 则更要加倍小心。



## 87. 考虑使用自定义的序列化形式





## 88. 保护性地编写 readObject 方法





## 89. 对于实例控制，枚举类型优先于 readResolve





## 90. 考虑用序列化代理代替序列化实例