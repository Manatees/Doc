## 通用编程

###57. 将局部变量的作用域最小化

本条目与第15条本质上是类似的。将局部变量的作用域最小化，可以增加代码的可读性和可维护性，并降低出错的可能性。

较早的编程语言（如 c 语言）要求局部变量必须在代码块的开头进行声明，出于习惯，有些程序员目前还是继续这样做。这个习惯应该改正。在此提醒，Java允许在任何可以出现语句的地方声明变量。

**要使局部变量的作用域最小化，最有力的方法就是在第一次要使用它的地方进行声明。** 如果变量在使用这前进行声明，这只会造成混乱——对于试图理解程序功能的读者来说，这又多了一种只会分散他们注意力的因素。等要用到该变量时，读者可能已经记不起该变量的类型或者初始值了。

 过早地声明局部变量不仅会使它的作用域过早地扩展，而且结束得过晚。局部变量的作用域从它被声明的点开始扩展，一直到外围块的结束处。如果变量是在 "使用它的块" 之外被声明的，当程序退出该块之后，该变量仍是可见的。如果变量在它的目标使用区域之前或之后被意外地使用，后果将可能是灾难性的。

**几乎每个局部变量的声明都应该是包含在一个初始化表达式。** 如果你还没有足够的信息来对一个变量进行有意义的初始化，就应该推迟这个声明，直到可以初始化为止。这条规则有个例外的情况与 try-catch 语句有关。如果一个变量被一个方法初始化，而这个方法可能会抛出一个受检异常，该变量就必须在 try 块的内部被初始化。如果变量的值必须在 try 块的外部用到，它就必须在 try 块之前被声明，但是在 try 块之前，它还不能被 "有意义地初始化"。请参照第 65 条中的例子。

循环中提供了特殊的机会来将变量的作用域最小化。无论是传统的 for 循环，还是 fore-each 形式的 for 循环，都允许声明循环变量(loop variable)，它们的作用域被限定在正好需要的范围之内。(这个范围包括循环体，以及循环体之前的初始化、测试、更新部分。) 因此，如果在循环终止之后不再需要循环变量的内容，**for 循环就优先于 while 循环。**

例如，下面是一种遍历集合的首先做法

```java
// Preferred idiom for iterating over a collection or array
for (Element e: c) {
    ... // Do Something with e
}
```

如果需要访问迭代器，可能要调用它的 remove 方法、首选做法是利用传统的 for 循环代替 for-each 循环

```java
// Idiom for iterating when you need the iterator
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
    Element e = i.next();
    ... // Do something with e and i
}
```

为了弄清楚为什么这些 for 循环比 while 循环更好，请参考下面的代码片段，它包含两个 while 循环，以及一个 Bug

```java
Iterator<Element> i = c.iterator();
while(i.hasNext()) {
    doSomething(i.next());
}
...
Iterator<Element> i2 = c2.iterator();
while(i.hasNext()) {				// BUG!
    doSomething(i2.next());
}
```

第二个循环中包含一个 "剪切 - 粘贴" 错误： 本来是要初始化一个新的循环变量 i2，却使用了旧的循环变量i，遗憾的是，这时 i 仍然还在有效范围之内。结果代码仍然可以通过编译，运行的时候也不会抛出异常，但是它所做的事情却是错误的。第二个循环并没有在 c2 上迭代，而是立即终止，造成 c2 为空的假象。因为这个程序的错误是悄然发生的，所以可能在很长时间内都不会被发现。

如果类似的 "剪切 - 粘贴" 错误发生在前面任何一种 for 循环中，结果代码根本就不能通过编译。在第二个循环开始之前，第一个循环的元素(或者迭代器)变量已经不在它的作用域范围之内了。下面就是一个传统 for 循环的例子

```java
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
    Element e = i.next();
    ... // Do something with e and i
}

...
// Compile-time error - cannot find symbol i
for (Iterator<Element> i2 = c2.iterator(); i.hasNext(); ) {
    Element e2 = i2.next();
    ... // Do something with e2 and i2
}
```






###for-each 循环优先于传统的 for 循环

###了解和使用类库

### 如果需要精确的答案，请避免使用 float 和 double



基本类型优先于装箱基本类型

如果其他类型更适合，则尽量避免使用字符串

了解字符串连接的性能

通过接口引用对象

接口优先于反射机制

谨慎地使用本地方法

谨慎地进行优化

遵守普遍接受的命名惯例
