## 通用编程

### 57. 将局部变量的作用域最小化

本条目与第15条本质上是类似的。将局部变量的作用域最小化，可以增加代码的可读性和可维护性，并降低出错的可能性。

较早的编程语言（如 c 语言）要求局部变量必须在代码块的开头进行声明，出于习惯，有些程序员目前还是继续这样做。这个习惯应该改正。在此提醒，Java允许在任何可以出现语句的地方声明变量。

**要使局部变量的作用域最小化，最有力的方法就是在第一次要使用它的地方进行声明。** 如果变量在使用这前进行声明，这只会造成混乱——对于试图理解程序功能的读者来说，这又多了一种只会分散他们注意力的因素。等要用到该变量时，读者可能已经记不起该变量的类型或者初始值了。

 过早地声明局部变量不仅会使它的作用域过早地扩展，而且结束得过晚。局部变量的作用域从它被声明的点开始扩展，一直到外围块的结束处。如果变量是在 "使用它的块" 之外被声明的，当程序退出该块之后，该变量仍是可见的。如果变量在它的目标使用区域之前或之后被意外地使用，后果将可能是灾难性的。

**几乎每个局部变量的声明都应该是包含在一个初始化表达式。** 如果你还没有足够的信息来对一个变量进行有意义的初始化，就应该推迟这个声明，直到可以初始化为止。这条规则有个例外的情况与 try-catch 语句有关。如果一个变量被一个方法初始化，而这个方法可能会抛出一个受检异常，该变量就必须在 try 块的内部被初始化。如果变量的值必须在 try 块的外部用到，它就必须在 try 块之前被声明，但是在 try 块之前，它还不能被 "有意义地初始化"。请参照第 65 条中的例子。

循环中提供了特殊的机会来将变量的作用域最小化。无论是传统的 for 循环，还是 fore-each 形式的 for 循环，都允许声明循环变量(loop variable)，它们的作用域被限定在正好需要的范围之内。(这个范围包括循环体，以及循环体之前的初始化、测试、更新部分。) 因此，如果在循环终止之后不再需要循环变量的内容，**for 循环就优先于 while 循环。**

例如，下面是一种遍历集合的首先做法

```java
// Preferred idiom for iterating over a collection or array
for (Element e: c) {
    ... // Do Something with e
}
```

如果需要访问迭代器，可能要调用它的 remove 方法、首选做法是利用传统的 for 循环代替 for-each 循环

```java
// Idiom for iterating when you need the iterator
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
    Element e = i.next();
    ... // Do something with e and i
}
```

为了弄清楚为什么这些 for 循环比 while 循环更好，请参考下面的代码片段，它包含两个 while 循环，以及一个 Bug

```java
Iterator<Element> i = c.iterator();
while(i.hasNext()) {
    doSomething(i.next());
}
...
Iterator<Element> i2 = c2.iterator();
while(i.hasNext()) {				// BUG!
    doSomething(i2.next());
}
```

第二个循环中包含一个 "剪切 - 粘贴" 错误： 本来是要初始化一个新的循环变量 `i2`，却使用了旧的循环变量i，遗憾的是，这时 i 仍然还在有效范围之内。结果代码仍然可以通过编译，运行的时候也不会抛出异常，但是它所做的事情却是错误的。第二个循环并没有在 `c2` 上迭代，而是立即终止，造成 `c2` 为空的假象。因为这个程序的错误是悄然发生的，所以可能在很长时间内都不会被发现。

如果类似的 "剪切 - 粘贴" 错误发生在前面任何一种 for 循环中，结果代码根本就不能通过编译。在第二个循环开始之前，第一个循环的元素(或者迭代器)变量已经不在它的作用域范围之内了。下面就是一个传统 for 循环的例子

```java
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
    Element e = i.next();
    ... // Do something with e and i
}

...
// Compile-time error - cannot find symbol i
for (Iterator<Element> i2 = c2.iterator(); i.hasNext(); ) {
    Element e2 = i2.next();
    ... // Do something with e2 and i2
}
```

如果使用 `for` 循环，犯这种 "剪切 - 粘贴" 错误的可能性就会大大降低，因为通常没有必要在两个循环中使用不同的变量名。循环是完全独立的，所以重用元素（或者迭代器）变量的名称不会有任何危害。实际上，这也是很流行的做法。

使用 `for` 循环与使用 `while` 循环相比还有另外一个优势：更简短，从而增强了可读性。

下面是另外一种对局部变量的作用域进行最小化的循环做法

```java
for (int i=0, n=expensiveComputation(); i<n; i++) {
    ... // Do something with i
}
```

关于这种做法要关注的重点是，它具有两个循环变量`i`和`n` ，二者具有完全相同的作用域。第二个变量`n` 被用来保存第一个变量的极限值，从而避免在每次迭代中执行冗余计算。通常，如果循环测试中涉及方法调用，并且可以保证在每次迭代中都会返回同样的结果，就应该使用这种做法。

最后一种 "将局部变量的作用域最小化" 的方法是**使方法小而集中**。如果把两个操作(activity)合并到同一个方法中，与其中一个操作相关的局部变量就有可能全会出执行另一个操作的代码范围之内。为了防止这种情况发生，只需将这个方法分成两个：每个操作作用一个方法来完成。



### 58. for-each 循环优先于传统的 for 循环

如第 45 条所述，有些任务最好结合 `Stream` 来完成，有些最好结合迭代完成。下面是用一个传统的`for`循环遍历集合的例子

```java
// Not the best way to iterate over a collection!
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
    Element e = i.next;
    ... // Do something with e
}
```

用传统的 `for` 循环遍历数组的做法如下

```java
// Not the best way to iterate over an array!
for (int i=0; i<a.length; i++) {
    ... // Do something with a[i]
}
```

这些做法都比 `while` 循环更好，但是它们并不完美。迭代器和索引变量都会造成一些混乱——而你需要的只是元素而已。而且，它们也代表着出错的可能。迭代器在每个循环中出现三次，索引变量在每个循环中出现四次，其中两次让你很容易出错。一旦出错，就无法保证编译器能够发现错误。最后一点是，这两个循环是截然不同的，容器的类型转移了不必要的注意力，并且为修改该类型增加了一些困难。

`for-each` 循环 (官方称之为 "增强的 `for` 语句")解决了所有问题。通过完全隐藏迭代器或者索引变量，避免了混乱和出错的可能。这处模式同样适用于集合和数组，同时简化了将容器的实现类型从一种转换到另一种的过程

```java
// The perferred idiom for iterating over collections and arrays
for (Element e : elements) {
    ... // Do somthing with e
}
```

当遇见冒号 `:` 时，可以把它读作 "在 `...`  里面"。因此上面的循环可以读作"对于元素 elements 中的每一个元素 e "。 注意，利用 `for-each` 循环不会有性能损失，甚至用于数组也一样，它们产生的代码本质上与手工编写的一样。

对于嵌套迭代，`for-each` 循环相对于传统 `for` 循环的优势还会更加明显。下面就是人们在试图对两个集合进行嵌套迭代时经常会犯的错误

```java
// can you spot the bug?
enum Suit { CLUB, DIAMOND, HEART, SPADE }
enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING }

...
static Collection<Suit> suits = Arrays.asList(Suit.values());
static Collection<Rank> ranks = Arrays.asList(Rank.values());

List<Card> deck = new ArrayList<>();
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); )
    for (Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
        deck.add(new Card(i.next(), j.next()));
```

如果之前没有发现这个 Bug 也不必难过，许多专家级的程序员偶尔也会犯这样的错误。问题在于，在迭代器上对外部的集合(suits) 调用了太多次`next` 方法。它应该从外部的循环进行调用，以便每种花色调用一次，但它却是从内部循环调用，因此每张牌调用一次。在用完所有花色之后，循环就会抛出`NoSuchElementException`异常。

如果真的那么不幸，并且外部集合的大小是内部集合大小的几倍(可能因为它们是相同的集合)，循环就会正常终止，但是不会完成你想要的工作。例如，下面就是一个考虑不周的尝试，想要打印一对骰子的所有可能的滚法

```java
// Same bug, different symptom!
enum Face { ONE, TWO, THREE, FOUR, FIVE, SIX }
...
Collection<Face> faces = EnumSet.allOf(Face.class);

for (Iterator<Face> i = faces.iterator(); i.hasNext(); )
    for (Iterator<Face> j = face.iterator(); j.hasNext(); )
        System.out.println(i.next() + " " + j.next());
```

这个程序不会抛出异常，面是只打印6个重复的词(从 "ONE ONE" 到 "SIX SIX")，而不是预计的那36种组合。

为了修正这些示例中的 bug， 必须在外部循环的作用域中添加一个变量来保存外部元素

```java
// Fixed, but ugly - you can do better!
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); ) {
    Suit suit = i.next();
    for (Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
        deck.add(new Card(suit, j.next()));
}
```

如果使用的是嵌套式`for-each`循环，这个问题就会完全消失。产生的代码将如你所希望的那样简洁

```java
// Preferred idiom for nested iteration on collections and arrays
for (Suit suit : suits) 
    for (Rank rank : ranks) 
        deck.add(new Card(suit, rank));
```

遗憾的是，有三种常见的情况无法使用for- each 循环：

* 解构过滤一一如果需要遍历集合，并删除选定的元素，就需要使用显式的迭代器，以便可以调用它的 `remove` 方法。使用Java 8 中增加的Collection 的 `removeIf` 方法，常常可以避免显式的遍历。
* 转换一一如果需要遍历列表或者数组，并取代它的部分或者全部元素值，就需要列表迭代器或者数组索引，以便设定元素的值。
* 平行迭代一一如果需要并行地遍历多个集合，就需要显式地控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以同步前进（就如上述有问题的牌和假子的示例中无意间所示范的那样）。如果你发现自己处于以上任何一种情况之下，就要使用普通的for 循环，并且要警惕本条目中提到的陷阱。

`for- each` 循环不仅能遍历集合和数组，还能遍历实现 `Iterable` 接口的任何对象，该接口中只包含单个方法，具体如下：

```java
public interface Iterable<E> {
    // Returns an iterator over the elements in this iterable
    Iterator<E> iterator();
}
```

如果不得不从头开始编写自己的 `Iterator` 实现，其中还是有些技巧的，但是如果编写的是表示一组元素的类型，则应该坚决考虑让它实现 `Iterable` 接口，甚至可以选择让它不要实现 `Collection` 接口。这样，你的用户就可以利用 `for- each` 循环遍历类型，他们会永远心怀感激的。

总而言之，与传统的 `for` 循环相比，`for-each` 循环在简洁性，灵活性以及出错预防性方面都占有绝对优势，并且没有性能惩罚的问题。因此，当可以选择的时候，`for-each` 循环应该优先于 `for` 循环。

### 59. 了解和使用类库

假设你希望产生位于0 和某个上界之间的随机整数。面对这个常见的任务，许多程序员会编写出如下所示的方法：

```java
// Common but deeply flawed!
static Random rnd = new Random();
static int random(int n) {
    return Math.abs(rnd.nextInt()) % n;
}
```

这个方法看起来可能不错，但是却有三个缺点。第一个缺点是，如果n 是一个比较小的2 的乘方，经过一段相当短的周期之后，它产生的随机数序列将会重复。第二个缺点是，如果n 不是2 的乘方，那么平均起来，有些数会比其他的数出现得更为频繁。如果n 比较大，这个缺点就会非常明显。这可以通过下面的程序直观地体现出来，它会产生100 万个经过精心指定的范围内的随机数，并打印出有多少个数字落在随机数取值范围的前半部分：

```java
public static void main(String[] args) {
    int n = 2 * (Integer.MAX_VALUE / 3);
    int low = 0;
    for (int i=0; i<1000000; i++)
        if (random(n) < n/2) 
            low++;
    System.out.println(low);    
}
```

如果 `random` 方法工作正常，这个程序打印出来的数将接近于 100 万的一半，但是如果真正运行这个程序，就会发现它打印出来的数接近于666666 。由random 方法产生的数字有三分之二落在随机数取值范围的前半部分。

`random` 方法的第三个缺点是，在极少数情况下，它的失败是灾难性的，因为会返回一个落在指定范围之外的数。之所以如此，是因为这个方法试图通过调用`Math.abs` ，将 `rnd.nextInt()` 返回的值映射为一个非负整数 `int` 。如果 `next!nt()` 返回`Integer.MIN_VALUE` ，那么 `Math.abs` 也会返回 `Integer.MIN_VALUE` ，假设 n 不是2 的乘方，那么取模操作符(%) 将返回一个负数。这几乎肯定会使程序失败，而且这种失败很难重现。

为了编写能修正这三个缺点的 `random` 方法，有必要了解关于同余伪随机数生成器、数论和2 的求补算法的相关知识。幸运的是，你并不需要自己来做这些工作一一已经有现成的成果可以为你所用。这一成果被称作`Random.nextInt(int)` 。你无须关心 `nextInt(int)` 的实现细节（如果你有强烈的好奇心，可以研究它的文档或者源代码) 。具有算法背景的高级工程师已经花了大量的时间来设计、实现和测试这个方法， 然后经过这个领域中的专家的审查，以确保它的正确性。之后，标准类库经过了Beta 测试并正式发行，几年之间已经有成千上万的程序员在使用它。在这个方法中还没有发现过缺陷，但是，如果将来发现有缺陷， 在下一个发行版本中就会修正这些缺陷。**通过使用标准类库，可以充分利用这些编写标准类库的专家的知识，以及在你之前的其他人的使用经验**。

从 Java 7 开始，就不应该再使用 `Random` 了。现在选择随机数生成器时，大多使用 `ThreadLocalRandom` 。它会产生更高质量的随机数，并且速度非常快。在我的机器上，比 `Random` 快了3.6 倍。对于`Fork` `Join` `Pool` 和并行 `Stream` ，则使用 `SplittableRandom` 。

使用标准类库的第二个好处是，不必浪费时间为那些与工作不太相关的问题提供特别的解决方案。就像大多数程序员一样，应该把时间花在应用程序上，而不是底层的细节上。

使用标准类库的第三个好处是， 它们的性能往往会随着时间的推移而不断提高，无须你做任何努力。因为许多人在使用它们，并且是当作工业标准在使用，所以提供这些标准类库的组织有强烈的动机要使它们运行得更快。这些年来，许多Java 平台类库已经被重新编写了，有时候是重复编写，从而在性能上有了显著的提高。

使用标准类库的第四个好处是，它们会随着时间的推移而增加新的功能。如果类库中漏掉了某些功能，开发者社区就会把这些缺点公示出来，漏掉的功能就会添加到后续的发行版本中。

使用标准类库的最后一个好处是，可以使自己的代码融入主流。这样的代码更易读、更易维护、更易被大多数的开发人员重用。

既然有那么多的优点，使用标准类库机制而不选择专门的实现，这显然是符合逻辑的，然而还是有相当一部分的程序员没有这样做。为什么呢？可能他们并不知道有这些类库机制的存在。**在每个重要的发行版本中，都 会有许多新的特性被加入到类库中，所以与这些新特性保持同步是值得的**。每当Java 平台有重要的发行时，都会发布一个网页来说明新的特性。这些网页值得好好读一读［Java8-feat, Java9-feat］ 。举个例子，假设想要编写一个程序，用它打印出命令行中指定的一条URL 的内容 (Linux 中 `curl` 命令的作用大体如此)。在Java 9之前，这些代码有点烦琐，但是Java 9 在 `InputStream` 中增加了 `transferTo` 方法。下面就是利用这个新方法完成这项任务的完整程序：

```java
// Printing the contents of a URL with transferTo, adde in Java9
public static void main(String[] args) throws IOException {
    try (InputStream in = new URL(args[0]).openStream()) {
        in.transferTo(System.out);
    }
}
```

这些标准类库太庞大了，以到于不可能学完所有的文档[Java9-api]，但是**每个程序员都应该熟悉 `java.lang` `java.util` `java.io` 及其子包中的内容**。关于其他类库的知识可以根据需要随时学习。总结类库中的机制超出了本条目的范围，几年来它们已经发展得十分庞大了。

其中有几个类库值得一提。Collections Framework （集合框架）和Stream 类库（详见第45条至第48 条）应该成为每一位程序员基本工具箱中的一部分，同样也应该成为`java.util.concurrent` 中并发机制的组成部分。这个包既包含高级的并发工具来简化多线程的编程任务，还包含低级别的并发基本类型，允许专家们自己编写更高级的井发抽象。关于 `Java.util.concurrent` 的高级部分，请参阅第80 条和第81 条。

在某些情况下，一个类库工具并不能满足你的需要。你的需求越是特殊，这种情形就越有可能发生。虽然你的第一个念头应该是使用标准类库，但是，如果你在观察了它们在某些领域所提供的功能之后，确定它不能满足需要，你就得使用其他的实现。任何一组类库所提供的功能总是难免会有遗漏。如果你在Java 类库中找不到所需要的功能，下一个选择应该是在高级的第三方类库中去寻找，比如Google 优秀的开源Guava 类库[Guava ] 。如果在所有相应的类库中都无法找到你所需的功能，就只能自己实现这些功能了。

总而言之，不要重复发明轮子。如果你要做的事情看起来是十分常见的，有可能类库中已经有某个类完成了这样的工作。如果确实是这样，就使用现成的；如果还不清楚是否存在这样的类，就去查一查。一般而言，类库的代码可能比你向己编写的代码更好一些，并且会随着时间的推移而不断改进。这并不是在质疑你作为一个程序员的能力。从经济角度的分析表明：类库代码受到的关注远远超过大多数普通程序员在同样的功能上所能给予的投入。

### 60. 如果需要精确的答案，请避免使用 float 和 double

`float` 和 `double` 类型主要是为了科学计算和工程计算而设计的。它们执行二进制浮，或运算（ binary floating-point arithmetic ），这是为了在广泛的数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们并没有提供完全精确的结果，所以不应该被用于需要精确结果的场合。**`float` 和 `double` 类型尤其不适合用于货币计算**。因为要让一个 `float` 或 `double` 精确地表示 `0.1`  (或者 10 的任何其他负数次方值)是不可能的。

例如，假设你的口袋中有\$1.03 ，花掉了42 美分之后还剩下多少钱呢？下面这个很简单的程序片段试图回答这个问题：

`System.out.println(1.03 - 0.42);`

遗憾的是，它输出的结果是0. 6100000000000001 。这并不是个别的例子。假设你的口袋里有$1 ，你买了9 个垫圈，每个为10 美分那么应该找回多少零头呢？

`System.out.println(1.00 - 9 * 0.10);`

根据上述程序片段，你得到的是$0.09999999999999998 美分

你可能会认为，只要在打印之前将结果做一下舍人就可以解决这个问题，但遗憾的是，这种做法并不总是可行的。例如，假设你的口袋里有\$1 ，你看到货架上有一排美昧的糖果，标价分别为10美分 、20美分 、30美分 ，等等，一直到\$1 。你打算从标价为10美分 的糖果开始，每种买 1 颗，一直到不能支付货架上下一种价格的糖果为止，那么你可以买多少颗糖果？还会找回多少零头？下面是一个简单的程序，用来解决这个问题：

```java
// Broken - uses floating point for monetary calculation!
public static void main(String[] args) {
    double funds = 1.00;
    int itemsBought = 0;
    for (double price = 0.10; funds >= price; price+=0.10) {
        funds -= price;
        itemsBought++;
    }
    System.out.println(itemsBought + " items bought.");
    System.out.println("Change: $" + funds);
}
```

如果真正运行这个程序，你会发现可以支付3 颗糖果，并且还剩下$0.3999999999999999 。
这个答案是不正确的！解决这个问题的正确方法是使用`BigDecirnal` 、`int` 或者`long` 进行货币计算。

下面的程序是上一个程序的简单翻版，它使用`BigDecimal` 类型代替double 。注意，它使用了`BigDecimal` 的`String` 构造器，而不是用`double` 构造器。为了避免将不正确的值引入到计算中，这是必需的 [Bloch05, Puzzle 2] :

```java
public static void main(String[] args) {
    final BigDecimal TEN_CENTS = new BigDecimal(".10");
    
    int itemsBought = 0;
    BigDecimal funds = new BigDecimal("1.00");
    for (BigDecimal price = TEN_CENTS; funds.compareTo(price) >= 0; price = funds.subtract(price)) {
        funds = funds.subtract(price);
        itemsBought++;
    }
    System.out.println(itemsBought + " items bought.");
    System.out.println("Change: $" + funds);   
}
```

如果运行这个修改过的程序，会发现可以支付4 颗糖果，还剩下$0.00 。这才是正确的答案。

然而，使用 `BigDecimal` 有两个缺点：与使用基本运算类型相比，这样做很不方便，而且速度很慢。对于解决这样一个简单的问题，后一种缺点并不要紧， 但是前一种缺点可能会让你很不舒服。

除了使用`BigDecimal` 之外，还有一种办法是使用`int` 或者`long` ，到底选用 `int` 还是 `long` 要取决于所涉及数值的大小，同时要自己处理十进制小数点。在这个示例中，最明显的做法是以分为单位进行计算，而不是以元为单位。下面是这个例子的简单翻版，展示了这种做法：

```java
public static void main(String[] args) {
    int itemsBought = 0;
    int funds = 100;
    for (int price=10; funds>=price; price+=10) {
        funds -= price;
        itemsBought++;
    }
    System.out.println(itemsBought + " items bought.");
    System.out.println("Change: $" + funds);
}
```

总而言之，对于任何需要精确答案的计算任务，请不要使用`float` 或者 `double` 。如果你想让系统来处理十进制小数点，并且不介意因为不使用基本类型而带来的不便，就请使用`BigDecimal` 。使用`BigDecimal` 还有一些额外的好处，它允许你完全控制舍人，每当一个操作涉及舍入的时候，你都可以从8 种舍入模式中选择其－ 。如果你正通过合法强制的舍入行为进行商务计算，使用`BigDecimal` 是非常方便的。如果性能非常关键，并且你又不介意自己处理十进制小数点，而且所涉及的数值又不太大，就可以使用`int` 或者`long` 。如果数值范围没有超过9 位十进制数字，就可以使用`int` ；如果不超过18 位数字，就可以使用`long` 。如果数值可能超过18 位数字，就必须使用 `BigDecimal` 。



## 61.基本类型优先于装箱基本类型

Java 有一个类型系统由两部分组成，它包含基本类型(primitive)，如 `int` 、`double` 和 `boolean` ，以及引用类型(reference type)，如String 和List 。每个基本类型都有一个对应的引用类型，称作装箱基本类型 (boxed primitive)。装箱基本类型中对应于`int`、`double` 和 `boolean` 的分别是 `Integer`, ` Double` 和`Boolean` 。

如第6 条中提到的，自动装箱(autoboxing) 和自动拆箱(auto-unboxing)模糊了但并没有完全抹去基本类型和装箱基本类型之间的区别。这两种类型之间真正是有差别的，要很清楚在使用的是哪种类型，并且要对这两种类型进行谨慎的选择，这些都非常重要。
在基本类型和装箱基本类型之间有三个主要区别。第一，基本类型只有值， 而装箱基本类型则具有与它们的值不同的同一性。换句话说，两个装箱基本类型可以具有相同的值和不同的同一性。第二，基本类型只有函数值，而每个装箱基本类型则都有一个非函数值，除了它对应基本类型的所有函数值之外，还有个null 。最后一点区别是，基本类型通常比装箱基本类型更节省时间和空间。如果不小心，这三点区别都会让你陷入麻烦之中。

以下面这个比较器为例，它被设计用来表示 `Integer` 值的递增数字顺序。(回想一下，比较器的 `compare` 方法返回的数值到底为负数、零还是正数，要取决于它的第一个参数是小于、等于还是大于它的第二个参数。) 在实践中并不需要你编写这个在 `Integer` 中实现自然顺序的比较器，因为这是不需要比较器就可以得到的，但它展示了一个有趣的例子：

```java
// Broken comparator - can you spot the flaw?
Comparator<Integer> naturalOrder = 
    (i, j) -> (i < j) ? -1 : ( i == j ? 0 : 1);
```

这个比较器表面看起来似乎不错，它可以通过许多测试。例如，它可以通过 `Collections .sort` 正确地给一个有100 万个元素的列表进行排序，无论这个列表中是否包含重复的元素。但是这个比较器有着严重的缺陷。如果你要让自己信服，只要打印 `naturalOrder.Compare(new Integer(42), new Integer(42))`的值便可以分晓。这两个 `Integer` 实例都表示相同的值（ 42 ） ，因此这个表达式的值应该为0 ，但它输出的却是1 ，这表明第一个 `Integer` 值大于第二个。

问题出在哪呢？ `naturalOrder` 中的第一个测试工作得很好。对表达式 `i < j` 执行计算会导致被 `i` 和 `j` 引用的`Integer` 实例被自动拆箱(auto-unboxed)；也就是说，它提取了它们的基本类型值。计算动作要检查产生的第一个 `int` 值是否小于第二个。但是假设答案是否定的。下一个测试就是执行计算表达式 `i == j`， 它在两个对象引用上执行同一性比较(identity comparison) 。如果 `i` 和 `j` 引用表示同一个 `int` 值的不同的 `Integer` 实例，这个比较操作就会返回 `false` ，比较器会错误地返回1 ，表示第一个Integer 值大于第二个。

**对装箱基本类型运用 `==` 操作符几乎总是错误的。**

事实上，如果需要用比较器描述一个类型的自然顺序，只要调用 `Comparator.naturalOrder()` 即可，如果自己编写比较器，则应该使用比较器构造方法，或者在基本类型上使用静态比较方法(详见第14 条) 。也就是说，修正这个问题的做法是添加两个局部变量， 来保存对应于装箱 `Integer` 参数的基本类型 `int` 值，并在这些变量上执行所有的比较操作。这样可以避免大量的同一性比较：

```java
Comparator<Integer> naturalOrder (iBoxed, jBoxed) -> {
    int i = iBoxed, j = jBoxed; // Auto-unboxing
    return i<j ? -1 : (i==j) ? 0 : 1);
}
```

接下来，看看下面这个小程序

```java
public class Unbelivable {
    static Integer i;
    public static void main(String[] args) {
        if (i==42) {
            System.out.println("Unbelievable");
        }
    }
}
```

它不会打印出 `Unbelievrable` —— 旦是它的行为也是很奇怪的。它在计算表达式 `( i == 42 )`的时候抛出`NullPointerException` 异常。问题在于， `i` 是个 `Integer` ，而不是 `int`, 就像所有的对象引用域一样，它的初始值为`null` 。 当程序计算表达式 `(i == 42)` 时，它会将 `Integer` 与 `int` 进行比较。几乎在任何一种情况下， 当在一项操作中混合使用基本类型和装箱基本类型时，装箱基本类型就会自动拆箱，这种情况无一例外。如果 `null` 对象引用被自动拆箱，就会抛出一个 `NullPointerException` 异常。就如这个程序所示，它几乎可以在任何位置发生。修正这个问题很简单，声明 `i` 是个 `int` 而不是 `Integer` 即可。

最后，以第6条中的这个程序为例：

```java
// Hideously slow program! Can you spot the object creation?
public static void main(String[] args) {
    Long sum = 0L;
    for (long i=0; i<Integer.MAX_VALUE; i++) {
        sum += i;
    }
    System.out.println(sum);
}
```

这个程序运行起来比预计的要慢一些，因为它不小心将一个局部变量 `sum` 声明为是装箱基本类型`Long`，而不是基本类型 `long` 。程序编译起来没有错误或者警告，变量被反复地装箱和拆箱，导致明显的性能下降。

在本条目中所讨论的这三个程序中，问题是一样的：程序员忽略了基本类型和装箱基本类型之间的区别，并尝到了苦头。在前两个程序中，其结果是彻底的失败；在第三个程序中，则有严重的性能问题。

那么什么时候应该使用装箱基本类型呢？它们有几个合理的用处。第一个是作为集合中的元素、键和值。你不能将基本类型放在集合中，因此必须使用装箱基本类型。这是一种更通用的特例。在参数化类型和方法（详见第5 章）中，必须使用装箱基本类型作为类型参数，因为Java 不允许使用基本类型。例如，你不能将变量声明为`ThreadLocal<int>`类型，因此必须使用 `ThreadLocal<Integer>` 代替。最后，在进行反射的方法调用（详见
第65 条） 时，必须使用装箱基本类型。

总而言之，当可以选择的时候，基本类型要优先于装箱基本类型。基本类型更加简单，也更加快速。如果必须使用装箱基本类型，要特别小心！ **自动装箱减少了使用装箱基本类型的烦琐性，但是并没有减少它的风险。**当程序用`==` 操作符比较两个装箱基本类型时，它做了个同一性比较，这几乎肯定不是你所希望的。当程序进行涉及装箱和拆箱基本类型的混合类型计算时，它会进行拆箱， **当程序进行拆箱时，会抛出 `NullPointerException` 异常**。最后，当程序装箱了基本类型值时，会导致较高的资源消耗和不必要的对象创建。



## 62. 如果其他类型更适合，则尽量避免使用字符串

字符串被用来表示文本，它在这方面也确实做得很好。因为字符串很通用，并且 Java 语言也支持得很好，所以自然就会有这样一种倾向：即使在不适合使用字符串的场合，人们往往也会使用字符串。本条目就是讨论一些不应该使用字符串的情形。

**字符串不适合代替其他的值类型**。当一段数据从文件、网络，或者键盘设备，进入程序之后，它通常以字符串的形式存在。有一种自然的倾向是让它继续保留这种形式，但是，只有当这段数据本质上确实是文本信息时，这种想法才是合理的。如果它是数值，就应该被转换为适当的数值类型，比如 `int` 、`float` 或者`BigInteger` 类型。如果它是个“是－或－否”这种问题的答案，就应该被转换为 `boolean` 类型。如果存在适当的值类型，不管是基本类型，还是对象引用，大多应该使用这种类型；如果不存在这样的类型，就应该编写一个类型。虽然这条建议是显而易见的，但通常未能得到遵守。

**字符串不适合代替枚举类型**。正如第34 条中所讨论的，枚举类型比字符串更加适合用来表示枚举类型的常量。

**字符串不适合代替聚合类型**。如果一个实体有多个组件，用一个字符串来表示这个实体通常是很不恰当的。例如，下面这行代码来自于真实的系统一一标识符的名称已经被修改了，以免发生纠纷：

```java
// Inappropriate use of string as aggregate type
String compoundKey = className + "#" + i.next();
```

这种方法有许多缺点。如果用来分隔域的字符也出现在某个域中，结果就会出现混乱。为了访问单独的域，必须解析该字符串，这个过程非常慢，也很烦琐，还容易出错。你无法提供 `equals` 、`toString` 或者 `compareTo` 方法，只好被迫接受String 提供的行为。更好的做法是，简单地编写一个类来描述这个数据集，通常是一个私有的静态成员类（详见第24 条） 。

**字符串也不适合代替能力表（ capabilities ）**。有时候，字符串被用于对某种功能进行授权访问。例如，考虑设计一个提供线程局部变量（ thread-local variable ）的机制。这个机制提供的变量在每个线程中都有自己的值。自Java 1.2 发行版本以来， Java 类库就有提供线程局部变量的机制，但在那之前，程序员必须自己完成。几年前，面对这样的设计任务时，有些人提出了同样的设计方案：利用客户提供的字符串键对每个线程局部变量的内容进行访问授权：

```java
// Broken - inappropriate use of string as capability!
public class ThreadLocal {
    private ThreadLocal() {} // Noninstantiable
    
    // Sets the current thread's value for the named variable.
    public static void set(String key, Object value);
    
    // Returns the current thread's value for the named variable.
    public static Object get(String key);
}
```

这种方法的问题在于，这些字符串键代表了一个共享的全局命名空间。要使这种方法可行，客户端提供的字符串键必须是唯一的：如果两个客户端各自决定为它们的线程局部变量使用同样的名称，它们实际上就无意中共享了这个变量，这样往往会导致两个客户端都失败，而且安全性也很差。恶意的客户端可能有意地使用与另一个客户端相同的键，以便非法地访问其他客户端的数据。

要修正这个 API 并不难，只要用一个不可伪造的键（有时称为能力）来代替字符串即可：

```java
public class ThreadLocal {
	private ThreadLocal() {} // Noninstantiable
    public static class Key { // (Capability)
        Key() {}
    }
    // Generates a unique, unforgeable key
    public static Key getKey() {
        reutrn new Key();
    }
    
    public static void set(Key key, Object object);
    public static Object get(Key key);
}
```

这样虽然解决了基于字符串的 API 的两个问题，但是你还可以做得更好。你实际上不再需要静态方法，它们可以被代之以键（ Key ）中的实例方法，这样这个键就不再是键，而是线程局部变量了。此时，这个不可被实例化的顶层类也不再做任何实质性的工作，因此可以删除这个顶层类，并将嵌套类命名为ThreadLocal:

```java
public final class ThreadLocal {
    public ThreadLocal();
    public void set(Object object);
    public Object get();
}
```

这个API 不是类型安全的，因为当你从线程局部变量得到它时，必须将值从Object转换成它实际的值。不可能使原始的基于String 的API 为类型安全的，要使基于Key 的API 为类型安全的也很困难，但是通过将ThreadLocal 类泛型化（详见第29 条），使这个API 变成类型安全的就是很简单的事情了：

```java
public final class ThreadLocal<T> {
    public ThreadLocal();
    public void Set(T value);
    public T get();
}
```

粗略地讲，这正是 `java .lang.ThreadLocal` 提供的API 。除了解决了基于字符串的API 的问题之外，与前面的两个基于键的API 相比，它还更快速、更美观。

总而言之，如果可以使用更加合适的数据类型，或者可以编写更加适当的数据类型，就应该避免用字符串来表示对象。若使用不当字符串会比其他的类型更加笨拙、更不灵活、速度更慢，也更容易出错。经常被错误地用字符串来代替的类型包括基本类型、枚举类型和聚合类型。



## 63.了解字符串连接的性能

字符串连接操作符 `＋` 是把多个字符串合并为一个字符串的便利途径。要想产生单独一行的输出，或者构造一个字符串来表示一个较小的、大小固定的对象，使用连接操作符是非常合适的，但是它不适合运用在大规模的场景中。为连接 n 个字符串而重复地使用字符串连接操作符，需要n 的平方级的时间。这是由于字符串不可变（详见第17 条）而导致的不幸结果。当两个字符串被连接在一起时，它们的内容都要被拷贝。

例如，下面的方法通过重复地为每个项目连接一行，构造出一个代表该账单声明的字符串：

```java
// Inappropriate use of string concatenation - Performs poorly!
public String statement() {
    String result = "";
    for (int i=0; i<numItems(); i++) {
        result += lineForItem(i); // String concatenation
    }
    return result;
}
```

如果项目的数量巨大，这个方法的执行时间就难以估算。为了获得可以接受的性能，请用 `StringBuilder` 代替 `String` ，来存储构造过程中的账单声明：

```java
public String statement() {
    StringBuilder b = new StringBuilder(numItems() * LINE_WIDTH);
    for (int i=0; i<numItems(); i++)
        b.append(lineForItem(i));
    return b.toString();
}
```

从Java 6 以来，已经做了大量的工作使字符串连接变得更加快速，但是上述两种做法的性能差别还是很大：如果`numIterns` 返回100 ，并且`lineForItem` 返回一个固定长度为 80 个字符的字符串，在我的机器上，第二种做法比第一种做法要快6.5 倍。因为第一种做法的开销随项目数量而呈平方级增加，项目的数量越大，性能的差别就会越明显。注意，第二种做法预先分配了一个 `StringBuilder` ，使它大到足以容纳整个结果字符串，因此不需要自动扩展。即使使用了默认大小的 `StringBuilder` ，它也仍然比第一种做法快 5.5 倍。

原则很简单： **不要使用字符串连接操作符来合并多个字符串**，除非性能无关紧要。否则，应该使用`StringBuilder` 的 `append` 方法。另一种做法是使用字符数组，或者每次只处理一个字符串，而不是将它们组合起来。



## 64.通过接口引用对象

第 51 条建议：应该使用接口而不是类作为参数类型。更通俗来讲，应该优先使用接口而不是类来引用对象。**如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应该使用接口类型进行声明**。只有当你利用构造器创建某个对象的时候，才真正需要引用这个对象的类。为了更具体地说明这一点，以 `LinkedHashSet` 的情形为例，它是 `Set` 接口的一个实现。在声明变量的时候应该养成这样的习惯：

```java
// Good - uses interface as type
Set<Son> sonSet = new LinkedHashSet<>();
```

而不是像这样的声明：

```java
// Bad - uses class as type!
LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
```

**如果养成了用接口作为类型的习惯，程序将会更加灵活**。当你决定更换实现时，所要做的就只是改变构造器中类的名称（或者使用一个不同的静态工厂）。例如，第一个声明可以被改变为：

```java
Set<Son> sonSet = new HashSet<>();
```

周围的所有代码都可以继续工作。周围的代码并不知道原来的实现类型，所以它们对于这种变化并不在意。

有一点值得注意： 如果原来的实现提供了某种特殊的功能，而这种功能并不是这个接口的通用约定所要求的，并且周围的代码又依赖于这种功能，那么很关键的一点是，新的实现也要提供同样的功能。例如，如果第一个声明周围的代码依赖于 `LinkedHashSet` 的同步策略，那么在声明中用 `HashSet` 代替 `LinkedHashSet` 就是不正确的，因为 `HashSet` 不能保证相关的迭代顺序。

为什么要改变实现类型呢？因为第二个实现提供了比第一个更好的性能，或者因为它提供了你所期待的而原来的实现缺乏的功能。比如，假设有一个域中包含了一个 `HashMap` 实例。如果将它改成 `EnumMap` ，则可以提供更好的性能，并且迭代顺序与键的自然顺序一致，但是如果键的类型为枚举类型，你就只能使用 `EnumMap` 。如果将`HashMap` 改成 `LinkdedHashMap` ， 则能提供可以预估的迭代顺序，以及可以与 `HashMap` 比拟的性能，对于键类型没有任何特殊的要求。

你可能会觉得，用变量的实现类型来声明变量，也是可以接受，因为可以同时改变声明类型和实现类型，但是不能确保修改后的程序可以编译。如果客户端代码使用了没有出现在新实现中的原始实现类型中的方法，或者客户端代码将该实例传到了需要原始实现类型的方法中，那么代码在完成这样的修改之后将不再进行编译。用接口类型声明变量要“保持诚实” 。

**如果没有合适的接口存在，完全可以用类而不是接口来引用对象**。以值类（ value class)为例，比如 `String` 和 `BigInteger` 。记住，值类很少会用多个实现编写。它们经常是 `final` 的，并且很少有对应的接口。使用这种值类作为参数、变量、域或者返回类型是再合适不过的了。

不存在适当接口类型的第二种情形是，对象属于一个框架，而框架的基本类型是类，不是接口。如果对象属于这种基于类的框架（ class-based framework ），就应该用相关的基类( base class) （往往是抽象类）来引用这个对象，而不是用它的实现类。许多 `java.io` 类，比如 `OutputStream` 就属于这种情形。

不存在适当接口类型的最后一种情形是，类实现了接口但它也提供了接口中不存在的额外方法一一例如`PriorityQueue` 有一个没有出现在 `Queue` 接口中的 `comparator` 方法。如果程序依赖于这些额外的方法，这种类就应该只被用来引用它的实例，永远也不应该被用作参数类型。

以上这些例子并不全面，而只是代表了一些“适合于用类来引用对象”的情形。实际上，给定的对象是否具有适当的接口应该是很显然的。如果是，用接口引用对象就会使程序更加灵活。**如果没有适合的接口，就用类层次结构中提供了必要功能的最小的具体类来引用对象吧**。



## 65.接口优先于反射机制

核心反射机制（ core reflection facility), `java.lang.reflect` 包，提供了“通过程序来访问任意类”的能力。给定一个 `Class 对象`，可以获得 `Constructor`、 `Method` 和 `Field` 实例，它们分别代表了该 Class 实例所表示的类的构造器、方法和域。这些对象提供了“通过程序来访问类的成员名称、域类型、方法签名等信息”的能力。

此外， `Constructor`,  `Method` 和 `Field` 实例使你能够通过反射机制操作它们的底层对等体： 通过调用`Constructor` 、`Method` 和 `Field` 实例上的方法，可以构造底层类的实例、调用底层类的方法，并访问底层类中的域。例如， `Method.invoke` 使你可以调用任何类的任何对象上的任何方法（遵从常规的安全限制）。反射机制允许一个类使用另一个类，即使当前者被编译的时候后者还根本不存在。然而，这种能力也要付出代价：

* **损失了编译时类型检查的优势**，包括异常检查。如果程序企图用反射方式调用不存在的或者不可访问的方法在运行时它将会失败，除非采取了特别的预防措施。

* **执行反射访问所需要的代码非常笨拙和冗长**。编写这样的代码非常乏味，阅读起来也很困难。

* **性能损失**。反射方法调用比普通方法调用慢了许多。具体慢了多少，这很难说，因为受到了多个因素的影响。在我的机器上，调用一个没有输入参数和int 返回值的方法，用普通方法调用比用反射机制调用快了11 倍。

有一些复杂的应用程序需要使用反射机制。这些示例包括代码分析工具和依赖注入框架。不过最近以来，这类工具已经不再使用反射机制，因为它的缺点越来越明显。如果你怀疑自己的应用程序是否也需要反射机制，它很有可能是不需要的。

**如果只是以非常有限的形式使用反射机制，虽然也要付出少许代价，但是可以获得许多好处**。许多程序必须用到的类在编译时是不可用的，但是在编译时存在适当的接口或者超类，通过它们可以引用这个类（详见第64 条） 。如果是这种情况，就可以**用反射方式创建实例，然后通过它们的接口或者超类，以正常的方式访问这些实例**。

例如，下面的程序创建了一个`Set<String>` 实例，它的类是由第一个命令行参数指定的。该程序把其余的命令行参数插入到这个集合中，然后打印该集合。不管第一个参数是什么，程序都会打印出余下的命令行参数，其中重复的参数会被消除掉。这些参数的打印顺序取决于第一个参数中指定的类。如果指定 `java.util.HashSet` ，显然这些参数就会以随机的顺序打印出来；如果指定`java.util.TreeSet` ，则会按照字母顺序打印，因为 `TreeSet` 中的元素是排好序的。相应的代码如下：

```java
// Reflective instantiation with interface access
public static void main(String[] args) {
    // Translate the class name into a Calss object
    Class<? extends Set<String>> cl = null;
    try {
        cl = (Class<? extends Set<String>>)Class.forName(args[0]); // Unchecked cast! 
    } catch(ClassNotFoundException e) {
        fatalError("Class not found");
    }
    
    // Get the constructor
    Constructor<? extends Set<String>> cons = null;
    try {
        cons = cl.getDeclaredConstructor();
    } catch(NoSuchMethodException e) {
        fatalError("No parameterless constructor");
    }
    
    // Instantiate the set
    Set<String> s = null;
    try {
        s = cons.newInstance();
    } catch(IllegalAccessException e) {
        fatalError("Constructor not accessible");
    } catch(InstantiationExecption e) {
        fatalError("Class not instantiable");
    } catch(InvocationTargetException e) {
        faltalError("Constructor threw " + e.getCause());
    } catch(ClassCastException e) {
        faltalError("Class doesn't implement set");
    }
    
    // Exerise the set
    s.addAll(Arrays.asList(args).subList(1, args.length));
    System.out.println(s);
}
private static void fatalError(String msg) {
    System.out.println(msg);
    System.exit(1);
}
```

尽管这只是一个试验程序，但是它所演示的方法是非常强大的。这个试验程序可以很容易地变成一个通用的集合测试器，通过侵入式地操作一个或者多个集合实例，并检查是否遵守Set 接口的约定，以此来验证指定的Set 实现。同样地，它也可以变成一个通用的集合性能分析工具。实际上，它所演示的这种方法足以实现一个成熟的服务提供者框架(service provider framework ），详见第 1 条。绝大多数情况下，使用反射机制时需要的也正是这种方法。

这个示例演示了反射机制的两个缺点。第一，这个例子会产生 6 个运行时异常，如果不使用反射方式的实例化，这 6 个错误都会成为编译时错误。（为了好玩，你也可以通过传入适当的命令行参数，让程序逐个生成这6 个异常。）第二，根据类名生成其实例需要25 行冗长的代码，而调用一个构造器则可以非常简洁地只用一行代码。程序的长度可以通过捕捉 `ReflectiveOperationException` 异常来减少，这是在Java 7 中引入的各种反射异常的一个超类。这两个缺点都局限于实例化对象的那部分代码。一旦对象被实例化，它与其他的
Set 实例就难以区分了。在实际的程序中，通过这种限定使用反射的方法，绝大部分代码可以不受影响。

如果试着编译这个程序，会得到一条未受检的转换警告。这条警告是合法的，因此转换 `Class<? extends Set<String>>`会成功，即使具名类不是一个Set 实现，在这种情况下，程序在实例化这个类时就会抛出一个`ClassCastException` 异常。耍了解禁止这种警告的最佳方法，请参见第27 条。

类对于在运行时可能不存在的其他类、方法或者域的依赖性，用反射法进行管理是合理的，但是很少使用。如果要编写一个包，井且它运行的时候就必须依赖其他某个包的多个版本，这种做法可能就非常有用。具体做法就是，在支持包所需要的最小环境下对它进行编译，通常是最老的版本，然后以反射方式访问任何更加新的类或者方法。如果企图访问的新类或者新方法在运行时不存在，为了使这种方法有效你还必须采取适当的动作。所谓适当的动作，可能包括使用某种其他可替换的办法来达到同样的目的，或者使用简化的功能进行处理。

总而言之，反射机制是一种功能强大的机制，对于特定的复杂系统编程任务，它是非常必要的，但它也有一些缺点。如果你编写的程序必须要与编译时未知的类一起工作，如有可能，就应该仅仅使用反射机制来实例化对象，而访问对象时则使用编译时已知的某个接口或者超类。



## 66. 谨慎地使用本地方法

Java Native Interface (JNI) 允许 Java 应用程序调用本地方法（ native method ），所谓本地方法是指用本地编程语言（比如C 或者C＋＋）来编写的方法。它们提供了“访问特定于平台的机制”的能力，比如访问注册表（ registry ） 。它们还提供了访问本地遗留代码库的能力，从而可以访问遗留数据（ legacy data ） 。最后，本地方法可以通过本地语言，编写应用程序中注重性能的部分，以提高系统的性能。

使用本地方法来访问特定于平台的机制是合法的，但是几乎没有必要：因为随着 Java 平台的不断成熟，它提供了越来越多以前只有在宿主平台上才拥有的特性。例如， Java 9 增加的进程API ，提供了访问操作系统进程的能力。当Java 中没有相当的类库可用时，使用本地方法来使用遗留代码库也是合法的。

**使用本地方法来提高性能的做法不值得提倡**。在早期的发行版本中（ Java 3 发行版本之前），这样做往往是很有必要的，但是从那以后， JVM 实现变得越来越快了。对于大多数任务，现在用 Java 就可以获得与之相当的性能。举例来说，当Java 1.1 发行版本中增加了`java.math` 时， `BigInteger` 是在一个用C 编写的快速多精度运算库的基础上实现的。在Java 3 发行版本中， `BigInteger` 则完全用Java 重新实现了，并且进行了精心的性能调优，运行得比原来的本地实现更快。

这个故事有一个悲伤的尾声： 从那时起， `BigInteger` 几乎没怎么改变，但在Java 8 中，大整数却以更快的乘积速度在发展。当时，遗留代码库的工作还在持续快速地发展中，著名的有GNU 高精度算术运算库（ GNU Multip l巳Precision , GMP ） 。对于需要真正高性能的高精度算术运算的Java 程序员，现在通过本地方法来使用GMP 也是无可厚非的［Blum l4］ 。

使用本地方法有一些严重的缺陷。因为本地语言不是安全的（详见第50 条），所以使用本地方法的应用程序也不再能免受内存毁坏错误的影响。因为本地语言是与平台相关的， 使用本地方法的应用程序也不再是可自由移植的。使用本地方法的应用程序也更难调试。如果不小心，本地方法还可能降低性能，因为回收垃圾器不是自动的，甚至无法追踪本机内存( native memory ）使用情况（详见第8 条），而且在进入和退出本地代码时，还需要相关的开销。最后一点，需要“胶合代码”的本地方法编写起来单调乏味，并且难以阅读。

总而言之，在使用本地方法之前务必三思。只有在极少数情况下需要使用本地方法来提高性能。如果你必须要使用本地方法来访问底层的资源，或者遗留代码库，也要尽可能少用本地代码，并且要全面进行测试。本地代码中只要有一个Bug 都可能破坏整个应用程序。



## 67.谨慎地进行优化

有三条与优化有关的格言是每个人都应该知道的：

> 很多计算上的过失都被归咎于效率 (没有达到必要的效率)，而不是任何其他的原因——甚至包括盲目地做傻事

> 不要去计较效率上的一些小小的得失，在97%的情况下，不成熟的优化才是一切问题的根源

> 在优化方面，我们应该遵守两条规则
>
> 规则1：不要进行优化
> 规则2 (仅针对专家)：还是不要进行优化 ——也就是说，在你还没有绝对清晰的未优化方案之前，请不要进行优化

所有这些格言都比 Java 程序设计语言的出现早了20 年。它们讲述了一个关于优化的深刻真理： 优化的弊大于利，特别是不成熟的优化。在优化过程中，产生的软件可能既不快速，也不正确，而且还不容易修正。

不要为了性能而牺牲合理的结构。**要努力编写好的程序而不是快的程序**。如果好的程序不够快，它的结构将使它可以得到优化。好的程序体现了信息隐藏（ information hiding)的原则：只要有可能，它们就会把设计决策集中在单个模块中，因此可以改变单个决策，而不会影响到系统的其他部分（详见第1 5 条） 。

这并不意味着，在完成程序之前就可以忽略性能问题。实现上的问题可以通过后期的优化而得到修正，但是，遍布全局并且限制性能的结构缺陷几乎是不可能被改正的，除非重新编写系统。在系统完成之后再改变设计的某个基本方面，会破坏系统的结构，从而难以维护和改进。因此，必须在设计过程中考虑到性能问题。

**要努力避免那些限制性能的设计决策**。当一个系统设计完成之后，其中最难以更改的组件是那些指定了模块之间交互关系以及模块与外界交互关系的组件。在这些设计组件之中，最主要的是AP I 、交互层（ wire -level ）协议以及永久数据格式。这些设计组件不仅在事后难以甚至不可能改变，而且它们都有可能对系统本该达到的性能产生严重的限制。

**要考虑API 设计决策的性能后果**。使公有的类型成为可变的，这可能会导致大量不必要的保护性拷贝（详见第50 条） 。同样地，在适合使用复合模式的公有类中使用继承，会把这个类与它的超类永远地束缚在一起，从而人为地限制了子类的性能（详见第1 8 条）。最后一个例子，在 API 中使用实现类型而不是接口，会把你束缚在一个具体的实现上，即使将来出现更快的实现你也无法使用（详见第64 条）。

API 设计对于性能的影响是非常实际的。以 `Java.awt.Component` 类中的 `getSize`方法为例。决定就是，这个注重性能的方法将返回`Dimension` 实例，与此密切相关的决定是， `Dimension` 实例是可变的，迫使这个方法的任何实现都必须为每个调用分配一个新的 `Dimension` 实例。尽管在现代VM 上分配小对象的开销并不大但是分配数百万个不必要的对象仍然会严重地损害性能。

在这种情况下，有几种可供选择的替换方案。理想情况下， `Dimension` 应该是不可变的（详见第17 条）；另一种方案是，用两个方法来替换 `getSize` 方法，它们分别返回 `Dimension` 对象的单个基本组件。实际上，在Java 2 发行版本中，出于性能方面的原因，有两个这样的方法被加入到Component API 中。然而，原先的客户端代码仍然可以使用 `getSize` 方法，并且仍然要承受原始API 设计决策所带来的性能影响。

幸运的是，一般而言，好的 API 设计也会带来好的性能。为获得好的性能而对 API 进行包装，这是一种非常不好的想法。导致你对 API 进行包装的性能因素可能会在平台未来的发行版本中，或者在将来的底层软件中不复存在，但是被包装的API 以及由它引起的问题将永远困扰着你。

一旦精心地设计了程序，并且产生了一个清晰、简明、结构良好的实现，那么就到了该考虑优化的时候了，假定此时你对于程序的性能还不满意。

回想一下Jackson 提出的两条优化原则： “不要优化”以及“（仅针对专家）还是不要优化” 。他可以再增加一条： **在每次试图做优化之前和之后，要对性能进行测量**。你可能会惊讶于自己的发现。试图做的优化通常对于性能并没有明显的影响，有时候甚至会使性能变得更差。主要原因在于，要猜出程序把时间花在哪些地方并不容易。你认为程序慢的地方可能并没有问题，这种情况下实际上是在浪费时间去尝试优化。大多数人认为： 程序把90% 的
时间花在10% 的代码上了。

性能剖析工具有助于决定应该把优化的重心放在哪里。这些工具可以为你提供运行时的信息，比如每个方法大致上花费了多少时间、它被调用多少次。除了确定优化的重点之外，它还可以警告你是否需要改变算法。如果一个平方级（或更差）的算法潜藏在程序中，无论怎么调整和优化都很难解决问题。你必须用更有效的算法来替换原来的算法。系统中的代码越多，使用性能剖析器就显得越发重要。这就好像要在一堆干草中寻找一根针： 这堆干草越大，使用金属探测器就越有用。值得特别提及的另一种工具是 `jmh` ，它不是一个性能剖析器，而是微基准测试框架（ microbenchmarking framework ），它提供了非并行地可见Java代码性能详情的能力［JMH］ 。

在Java 平台上对优化的结果进行测量，比在其他的传统平台（如C 和C＋＋）上更有必要，因为Java 程序设计语言没有很强的性能模型（ performance model ）：各种基本操作的相对开销也没有明确定义。程序员所编写的代码与CPU 执行的代码之间存在“语义沟”( semantic gap ），而且这条语义沟比传统编译语言中的更大，这使得要想可靠地预测出任何优化的性能结果都非常困难。大量流传的关于性能的说法最终都被证明为半真半假，或者根本就不正确。

不仅Java 的性能模型未得到很好的定义，而且在不同的 JVM  实现，不同的发行版本，以及不同的处理器中，也都各不相同。如果将要在多个 JVM 实现和多种硬件平台上运行程序，很重要的一点是，需要在每个Java 实现上测量优化效果。有时－候，还必须在从不同 JVM 实现或者硬件平台上得到的性能结果之中进行权衡。

自从本条目开始编写以来的近二十年， Java 软件堆校的每一个组件都变得更加复杂，从管理器到虚拟机，再到类库，运行Java 的各种硬件也得到了迅猛的发展。这些因素结合起来导致现在Java 程序的性能比 2001 年时更难以预测了，因此对测量性能的需求也相应地增加了。

总而言之，不要费力去编写快速的程序——应该努力编写好的程序，速度自然会随之而来。但在设计系统的时候，特别是在设计API 、交互层协议和永久数据格式的时候，一定要考虑性能的因素。当构建完系统之后，要测量它的性能。如果它足够快，你的任务就完成了。如果不够快，则可以在性能剖析器的帮助下，找到问题的根源，然后设法优化系统中相关的部分。第一个步骤是检查所选择的算法：再多的低层优化也无法弥补算法的选择不当。
必要时重复这个过程，在每一次修改之后都要测量性能，直到满意为止。

## 68.遵守普遍接受的命名惯例

Java 平台建立了一整套很好的命名惯例（ naming convention ），其中有许多命名惯例包含在了《The Java Language Specification > [JLS, 6.1 ］中。不严格地讲，这些命名惯例分为两大类：字面的（ typographica l ）和语法的 (grammatical )。

字面的命名惯例比较少，但也涉及包、类、接口、方法、域和类型变量。应该尽量不违反这些惯例，不到万不得已，千万不要违反。如果API 违反了这些惯例，使用起来可能会很困难。如果实现违反了它们，可能会难以维护。在这两种情况下，违反惯例都会潜在地给使用这些代码的其他程序员带来困惑和苦恼，并且使他们做出错误的假设，造成程序出错。本条目将对这些惯例做简要的介绍。

包和模块的名称应该是层次状的，用句号分隔每个部分。每个部分都包括小写字母，极少数情况下还有数字。任何将在你的组织之外使用的包，其名称都应该以你的组织的 Internet 域名开头，并且顶级域名要放在前面，例如`edu.cmu` 、`com.google` 、`org.eff` 。标准类库和一些可选的包，其名称以 java 和 javax 开头，它们属于这一规则的例外。用户创建的包的名称绝不能以 java 和 javax 开头。关于将Internet 域名转换为包名称前缀的详细规则，请参见《The Java Language Specification > [JLS, 6.1 ］ 。

包名称的其余部分应该包括一个或者多个描述该包的组成部分。这些组成部分应该比较简短，通常不超过8 个字符。鼓励使用有意义的缩写形式，例如，使用 util 而不是 utilities 。只取首字母的缩写形式也是可以接受的，例如awt 。每个组成部分通常都应该由一个单词或者一个缩写词组成。

许多包的名称中都只有一个组成部分再加上Internet 域名。比较大的名称使用附加部分是正确的，它们的规模要求它们要被分割成一个非正式的层次结构。例如， `javax.util` 包有着非常丰富的包层次如 `javax.util.concurrent.atomic` 。这样的包通常被称为子包（ subpackage ），尽管Java 语言并没有提供对包层次的支持。

类和接口的名称，包括枚举和注解类型的名称，都应该包括一个或者多个单词，每个单词的首字母大写，例如 `List` 和 `FutureTask` 。应该尽量避免用缩写，除非是一些首字母缩写和一些通用的缩写，比如 max 和 min 。对于首字母缩写，到底应该全部大写还是只有首字母大写，没有统一的说法。虽然有些程序员仍然采用全部大写的形式，但还是有人强烈支持只首字母大写：即使连续出现多个首字母缩写的形式，你仍然可以区分出一个单词的起始处和结束处。比如类名`HTTPURL` 和 `HttpUri` 你更愿意看到哪一个？

方法和域的名称与类和接口的名称一样，都遵守相同的字面惯例，只不过方法或者域的名称的第一个字母应该小写，例如 `remove` 、`ensureCapacity` 。如果由首字母缩写组成的单词是一个方法或者域名称的第一个单词，它就应该是小写形式。

上述规则的唯一例外是“常量域”，它的名称应该包含一个或者多个大写的单词，中间用下划线符号隔开，例如 `VALUES` 或 `NEGATIVE_INFINITY` 。常量域是个静态final 域，它的值是不可变的。如果静态final 域有基本类型，或者有不可变的引用类型（详见第17条），它就是个常量域。例如，枚举常量是常量域。如果静态final 域有个可变的引用类型，若被引用的对象是不可变的，它也仍然可以是个常量域。注意，常量域是唯一推荐使用下划线的情形。

局部变量名称的字丽命名惯例与成员名称类似，只不过它也允许缩写，单个字符和短字符序列的意义取决于局部变量所在的上下文环境，例如 `i` 、`denom` 和 `houseNum`。输入参数是一种特殊的局部变量。它们的命名应该比普通的局部变量更加小心，因为它们的名称是其方法文档的一个组成部分。

类型参数名称通常由单个字母组成。这个字母通常是以下五种类型之一： T 表示任意的类型， E 表示集合的元素类型， K 和 V 表示映射的键和值类型， X 表示异常。函数的返回类型通常是 R 。任何类型的序列可以是 T 、U 、V 或者Tl 、T2 、T3 。

为了快速查阅，下表列出了字面惯例的例子。

| 标识符类型 | 示例                                                  |
| ---------- | ----------------------------------------------------- |
| 包或模块   | `org.junit.jupiter.api`, `com.goolge.common.collect`  |
| 类或接口   | `Stream`, `FutureTask`, `LinkedHashMap`, `HttpClient` |
| 方法或域   | `remove`, `groupingBy`, `getCrc`                      |
| 常量域     | `MIN_VALUE`, `NEGATIVE_INFINITY`                      |
| 局部变量   | `i`, `denom`, `houseNum`                              |
| 类型参数   | `T`, `E`, `K`, `V`, `X`, `R`, `U`, `V`, `T1`, `T2`    |

语法命名惯例比字面惯例更加灵活，也更有争议。对于包而言，没有语法命名惯例。可被实例化的类（包括枚举类型）通常用一个名词或者名词短语命名， 例如`Thread` 、`PriorityQueue` 或者`ChessPiece` 。不可实例化的工具类（详见第4 条）经常用复数名词命名，如 `Collectors` 或者 `Collections` 。接口的命名与类相似，例如`Collection` 或 `Comparator` ，或者用一个以 `able` 或 `ible` 结尾的形容同来命名，例如 `Runnable` 、`Iterable` 或者 `Accessible` 。由于注解类型有这么多用处，因此没有单独安排词类。名词、动词、介词和形容词都很常用，例如 `BindingAnnotation` 、`Inject` 、`ImplementedBy` 或者 `Singleton` 。

执行某个动作的方法通常用动词或者动词短谓（包括对象）来命名，例如 `append` 或`drawImage` 。对于返回`boolean` 值的方法，其名称往往以单词 `is` 开头，很少用 `has` ，后面跟名词或名词短话，或者任何具有形容词功能的单词或短语，例如 `isDigit` 、`isProbablePrime` 、`isEmpty` 、`isEnabled` 或者 `hasSiblings`。

如果方法返回被调用对象的一个非 `boolean` 的函数或者属性，它通常用名词、名词短语，或者以动词get 开头的动词短语来命名，例如 `size` 、`hashCode` 或者 `getTime`。 有一个组织声称只有第三种形式（ 以get 开头）才可以接受，但是这种声明没有得到支持。前两种形式往往会产生可读性更好的代码，例如：

```java
if (car.speed() > 2 * SPEED_LIMIT)
    generateAudibleAlert("Watch out for cops!");
```

以 get  开头的形式主要出现在被废弃的Java Beans 规范中，它形成了早期的可重用组件架构的基础。有些现代工具继续依赖Beans 命名惯例，你大可放心地在那些需要结合这些工具一起使用的代码中使用。如果类中包含了用于相同属性的 **setter** 方法和 **getter** 方法，也强烈建议采用这种命名形式。在这种情况下，这两种方法应该分别被命名为get Attribute 和set Attribute。

有些方法的名称值得专门提及。转换对象类型的实例方法，它们返回不同类型的独立对象的方法， 经常被称为to Type ，例如 `toString` 或者 `toArray` 。返回视图（ view ，详见第6 条，视图的类型不同于接收对象的类型）的方法经常被称为 as Type，例如 `asList` 。返回一个与被调用对象同值的基本类型的方法，经常被称为 type Value ，例如 `intValue` 。静态工厂的常用名称包括 `from` 、`of` 、`valueOf` 、`instance` 、`getInstance` 、`newInstance` 、`getType` 和 `newType` （详见第1 条） 。

域名称的语法惯例没有很好地建立起来，它们也没有类、接口和方法名称那么重要，因为设计良好的API 很少会包含暴露出来的域。`boolean` 类型的域命名与 `boolean` 类型的访问方法（ accessor method ）很类似，但是省去了初始的坷，例如 `initialized` 和 `composite` 。其他类型的域通常用名词或者名词短语来命名，比如 `height` 、`digits` 或 `bodyStyle` 。局部变量的语法惯例类似于域的语法惯例，但是更弱一些。

总而言之，把标准的命名惯例当作一种内在的机制来看待，并且学着用它们作为第二特性。字面惯例是非常直接和明确的·语法惯例则更复杂，也更松散。下面这句话引自<The Java Language Specification > [JLS, 6.1 ］：“如果长期养成的习惯用法与此不同，请不要盲目遵从这些命名惯例。”请使用大家公认的做法。

