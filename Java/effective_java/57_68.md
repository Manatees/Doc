## 通用编程

### 57. 将局部变量的作用域最小化

本条目与第15条本质上是类似的。将局部变量的作用域最小化，可以增加代码的可读性和可维护性，并降低出错的可能性。

较早的编程语言（如 c 语言）要求局部变量必须在代码块的开头进行声明，出于习惯，有些程序员目前还是继续这样做。这个习惯应该改正。在此提醒，Java允许在任何可以出现语句的地方声明变量。

**要使局部变量的作用域最小化，最有力的方法就是在第一次要使用它的地方进行声明。** 如果变量在使用这前进行声明，这只会造成混乱——对于试图理解程序功能的读者来说，这又多了一种只会分散他们注意力的因素。等要用到该变量时，读者可能已经记不起该变量的类型或者初始值了。

 过早地声明局部变量不仅会使它的作用域过早地扩展，而且结束得过晚。局部变量的作用域从它被声明的点开始扩展，一直到外围块的结束处。如果变量是在 "使用它的块" 之外被声明的，当程序退出该块之后，该变量仍是可见的。如果变量在它的目标使用区域之前或之后被意外地使用，后果将可能是灾难性的。

**几乎每个局部变量的声明都应该是包含在一个初始化表达式。** 如果你还没有足够的信息来对一个变量进行有意义的初始化，就应该推迟这个声明，直到可以初始化为止。这条规则有个例外的情况与 try-catch 语句有关。如果一个变量被一个方法初始化，而这个方法可能会抛出一个受检异常，该变量就必须在 try 块的内部被初始化。如果变量的值必须在 try 块的外部用到，它就必须在 try 块之前被声明，但是在 try 块之前，它还不能被 "有意义地初始化"。请参照第 65 条中的例子。

循环中提供了特殊的机会来将变量的作用域最小化。无论是传统的 for 循环，还是 fore-each 形式的 for 循环，都允许声明循环变量(loop variable)，它们的作用域被限定在正好需要的范围之内。(这个范围包括循环体，以及循环体之前的初始化、测试、更新部分。) 因此，如果在循环终止之后不再需要循环变量的内容，**for 循环就优先于 while 循环。**

例如，下面是一种遍历集合的首先做法

```java
// Preferred idiom for iterating over a collection or array
for (Element e: c) {
    ... // Do Something with e
}
```

如果需要访问迭代器，可能要调用它的 remove 方法、首选做法是利用传统的 for 循环代替 for-each 循环

```java
// Idiom for iterating when you need the iterator
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
    Element e = i.next();
    ... // Do something with e and i
}
```

为了弄清楚为什么这些 for 循环比 while 循环更好，请参考下面的代码片段，它包含两个 while 循环，以及一个 Bug

```java
Iterator<Element> i = c.iterator();
while(i.hasNext()) {
    doSomething(i.next());
}
...
Iterator<Element> i2 = c2.iterator();
while(i.hasNext()) {				// BUG!
    doSomething(i2.next());
}
```

第二个循环中包含一个 "剪切 - 粘贴" 错误： 本来是要初始化一个新的循环变量 `i2`，却使用了旧的循环变量i，遗憾的是，这时 i 仍然还在有效范围之内。结果代码仍然可以通过编译，运行的时候也不会抛出异常，但是它所做的事情却是错误的。第二个循环并没有在 `c2` 上迭代，而是立即终止，造成 `c2` 为空的假象。因为这个程序的错误是悄然发生的，所以可能在很长时间内都不会被发现。

如果类似的 "剪切 - 粘贴" 错误发生在前面任何一种 for 循环中，结果代码根本就不能通过编译。在第二个循环开始之前，第一个循环的元素(或者迭代器)变量已经不在它的作用域范围之内了。下面就是一个传统 for 循环的例子

```java
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
    Element e = i.next();
    ... // Do something with e and i
}

...
// Compile-time error - cannot find symbol i
for (Iterator<Element> i2 = c2.iterator(); i.hasNext(); ) {
    Element e2 = i2.next();
    ... // Do something with e2 and i2
}
```

如果使用 `for` 循环，犯这种 "剪切 - 粘贴" 错误的可能性就会大大降低，因为通常没有必要在两个循环中使用不同的变量名。循环是完全独立的，所以重用元素（或者迭代器）变量的名称不会有任何危害。实际上，这也是很流行的做法。

使用 `for` 循环与使用 `while` 循环相比还有另外一个优势：更简短，从而增强了可读性。

下面是另外一种对局部变量的作用域进行最小化的循环做法

```java
for (int i=0, n=expensiveComputation(); i<n; i++) {
    ... // Do something with i
}
```

关于这种做法要关注的重点是，它具有两个循环变量`i`和`n` ，二者具有完全相同的作用域。第二个变量`n` 被用来保存第一个变量的极限值，从而避免在每次迭代中执行冗余计算。通常，如果循环测试中涉及方法调用，并且可以保证在每次迭代中都会返回同样的结果，就应该使用这种做法。

最后一种 "将局部变量的作用域最小化" 的方法是**使方法小而集中**。如果把两个操作(activity)合并到同一个方法中，与其中一个操作相关的局部变量就有可能全会出执行另一个操作的代码范围之内。为了防止这种情况发生，只需将这个方法分成两个：每个操作作用一个方法来完成。



### 58. for-each 循环优先于传统的 for 循环

如第 45 条所述，有些任务最好结合 `Stream` 来完成，有些最好结合迭代完成。下面是用一个传统的`for`循环遍历集合的例子

```java
// Not the best way to iterate over a collection!
for (Iterator<Element> i = c.iterator(); i.hasNext(); ) {
    Element e = i.next;
    ... // Do something with e
}
```

用传统的 `for` 循环遍历数组的做法如下

```java
// Not the best way to iterate over an array!
for (int i=0; i<a.length; i++) {
    ... // Do something with a[i]
}
```

这些做法都比 `while` 循环更好，但是它们并不完美。迭代器和索引变量都会造成一些混乱——而你需要的只是元素而已。而且，它们也代表着出错的可能。迭代器在每个循环中出现三次，索引变量在每个循环中出现四次，其中两次让你很容易出错。一旦出错，就无法保证编译器能够发现错误。最后一点是，这两个循环是截然不同的，容器的类型转移了不必要的注意力，并且为修改该类型增加了一些困难。

`for-each` 循环 (官方称之为 "增强的 `for` 语句")解决了所有问题。通过完全隐藏迭代器或者索引变量，避免了混乱和出错的可能。这处模式同样适用于集合和数组，同时简化了将容器的实现类型从一种转换到另一种的过程

```java
// The perferred idiom for iterating over collections and arrays
for (Element e : elements) {
    ... // Do somthing with e
}
```

当遇见冒号 `:` 时，可以把它读作 "在 `...`  里面"。因此上面的循环可以读作"对于元素 elements 中的每一个元素 e "。 注意，利用 `for-each` 循环不会有性能损失，甚至用于数组也一样，它们产生的代码本质上与手工编写的一样。

对于嵌套迭代，`for-each` 循环相对于传统 `for` 循环的优势还会更加明显。下面就是人们在试图对两个集合进行嵌套迭代时经常会犯的错误

```java
// can you spot the bug?
enum Suit { CLUB, DIAMOND, HEART, SPADE }
enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING }

...
static Collection<Suit> suits = Arrays.asList(Suit.values());
static Collection<Rank> ranks = Arrays.asList(Rank.values());

List<Card> deck = new ArrayList<>();
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); )
    for (Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
        deck.add(new Card(i.next(), j.next()));
```

如果之前没有发现这个 Bug 也不必难过，许多专家级的程序员偶尔也会犯这样的错误。问题在于，在迭代器上对外部的集合(suits) 调用了太多次`next` 方法。它应该从外部的循环进行调用，以便每种花色调用一次，但它却是从内部循环调用，因此每张牌调用一次。在用完所有花色之后，循环就会抛出`NoSuchElementException`异常。

如果真的那么不幸，并且外部集合的大小是内部集合大小的几倍(可能因为它们是相同的集合)，循环就会正常终止，但是不会完成你想要的工作。例如，下面就是一个考虑不周的尝试，想要打印一对骰子的所有可能的滚法

```java
// Same bug, different symptom!
enum Face { ONE, TWO, THREE, FOUR, FIVE, SIX }
...
Collection<Face> faces = EnumSet.allOf(Face.class);

for (Iterator<Face> i = faces.iterator(); i.hasNext(); )
    for (Iterator<Face> j = face.iterator(); j.hasNext(); )
        System.out.println(i.next() + " " + j.next());
```

这个程序不会抛出异常，面是只打印6个重复的词(从 "ONE ONE" 到 "SIX SIX")，而不是预计的那36种组合。

为了修正这些示例中的 bug， 必须在外部循环的作用域中添加一个变量来保存外部元素

```java
// Fixed, but ugly - you can do better!
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); ) {
    Suit suit = i.next();
    for (Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
        deck.add(new Card(suit, j.next()));
}
```

如果使用的是嵌套式`for-each`循环，这个问题就会完全消失。产生的代码将如你所希望的那样简洁

```java
// Preferred idiom for nested iteration on collections and arrays
for (Suit suit : suits) 
    for (Rank rank : ranks) 
        deck.add(new Card(suit, rank));
```

遗憾的是，有三种常见的情况无法使用for- each 循环：

* 解构过滤一一如果需要遍历集合，并删除选定的元素，就需要使用显式的迭代器，以便可以调用它的 `remove` 方法。使用Java 8 中增加的Collection 的 `removeIf` 方法，常常可以避免显式的遍历。
* 转换一一如果需要遍历列表或者数组，并取代它的部分或者全部元素值，就需要列表迭代器或者数组索引，以便设定元素的值。
* 平行迭代一一如果需要并行地遍历多个集合，就需要显式地控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以同步前进（就如上述有问题的牌和假子的示例中无意间所示范的那样）。如果你发现自己处于以上任何一种情况之下，就要使用普通的for 循环，并且要警惕本条目中提到的陷阱。

`for- each` 循环不仅能遍历集合和数组，还能遍历实现 `Iterable` 接口的任何对象，该接口中只包含单个方法，具体如下：

```java
public interface Iterable<E> {
    // Returns an iterator over the elements in this iterable
    Iterator<E> iterator();
}
```

如果不得不从头开始编写自己的 `Iterator` 实现，其中还是有些技巧的，但是如果编写的是表示一组元素的类型，则应该坚决考虑让它实现 `Iterable` 接口，甚至可以选择让它不要实现 `Collection` 接口。这样，你的用户就可以利用 `for- each` 循环遍历类型，他们会永远心怀感激的。

总而言之，与传统的 `for` 循环相比，`for-each` 循环在简洁性，灵活性以及出错预防性方面都占有绝对优势，并且没有性能惩罚的问题。因此，当可以选择的时候，`for-each` 循环应该优先于 `for` 循环。

### 59. 了解和使用类库

假设你希望产生位于0 和某个上界之间的随机整数。面对这个常见的任务，许多程序员会编写出如下所示的方法：

```java
// Common but deeply flawed!
static Random rnd = new Random();
static int random(int n) {
    return Math.abs(rnd.nextInt()) % n;
}
```

这个方法看起来可能不错，但是却有三个缺点。第一个缺点是，如果n 是一个比较小的2 的乘方，经过一段相当短的周期之后，它产生的随机数序列将会重复。第二个缺点是，如果n 不是2 的乘方，那么平均起来，有些数会比其他的数出现得更为频繁。如果n 比较大，这个缺点就会非常明显。这可以通过下面的程序直观地体现出来，它会产生100 万个经过精心指定的范围内的随机数，并打印出有多少个数字落在随机数取值范围的前半部分：

```java
public static void main(String[] args) {
    int n = 2 * (Integer.MAX_VALUE / 3);
    int low = 0;
    for (int i=0; i<1000000; i++)
        if (random(n) < n/2) 
            low++;
    System.out.println(low);    
}
```

如果 `random` 方法工作正常，这个程序打印出来的数将接近于 100 万的一半，但是如果真正运行这个程序，就会发现它打印出来的数接近于666666 。由random 方法产生的数字有三分之二落在随机数取值范围的前半部分。

`random` 方法的第三个缺点是，在极少数情况下，它的失败是灾难性的，因为会返回一个落在指定范围之外的数。之所以如此，是因为这个方法试图通过调用`Math.abs` ，将 `rnd.nextInt()` 返回的值映射为一个非负整数 `int` 。如果 `next!nt()` 返回`Integer.MIN_VALUE` ，那么 `Math.abs` 也会返回 `Integer.MIN_VALUE` ，假设 n 不是2 的乘方，那么取模操作符(%) 将返回一个负数。这几乎肯定会使程序失败，而且这种失败很难重现。

为了编写能修正这三个缺点的 `random` 方法，有必要了解关于同余伪随机数生成器、数论和2 的求补算法的相关知识。幸运的是，你并不需要自己来做这些工作一一已经有现成的成果可以为你所用。这一成果被称作`Random.nextInt(int)` 。你无须关心 `nextInt(int)` 的实现细节（如果你有强烈的好奇心，可以研究它的文档或者源代码) 。具有算法背景的高级工程师已经花了大量的时间来设计、实现和测试这个方法， 然后经过这个领域中的专家的审查，以确保它的正确性。之后，标准类库经过了Beta 测试并正式发行，几年之间已经有成千上万的程序员在使用它。在这个方法中还没有发现过缺陷，但是，如果将来发现有缺陷， 在下一个发行版本中就会修正这些缺陷。**通过使用标准类库，可以充分利用这些编写标准类库的专家的知识，以及在你之前的其他人的使用经验**。

从 Java 7 开始，就不应该再使用 `Random` 了。现在选择随机数生成器时，大多使用 `ThreadLocalRandom` 。它会产生更高质量的随机数，并且速度非常快。在我的机器上，比 `Random` 快了3.6 倍。对于`Fork` `Join` `Pool` 和并行 `Stream` ，则使用 `SplittableRandom` 。

使用标准类库的第二个好处是，不必浪费时间为那些与工作不太相关的问题提供特别的解决方案。就像大多数程序员一样，应该把时间花在应用程序上，而不是底层的细节上。

使用标准类库的第三个好处是， 它们的性能往往会随着时间的推移而不断提高，无须你做任何努力。因为许多人在使用它们，并且是当作工业标准在使用，所以提供这些标准类库的组织有强烈的动机要使它们运行得更快。这些年来，许多Java 平台类库已经被重新编写了，有时候是重复编写，从而在性能上有了显著的提高。

使用标准类库的第四个好处是，它们会随着时间的推移而增加新的功能。如果类库中漏掉了某些功能，开发者社区就会把这些缺点公示出来，漏掉的功能就会添加到后续的发行版本中。

使用标准类库的最后一个好处是，可以使自己的代码融入主流。这样的代码更易读、更易维护、更易被大多数的开发人员重用。

既然有那么多的优点，使用标准类库机制而不选择专门的实现，这显然是符合逻辑的，然而还是有相当一部分的程序员没有这样做。为什么呢？可能他们并不知道有这些类库机制的存在。**在每个重要的发行版本中，都 会有许多新的特性被加入到类库中，所以与这些新特性保持同步是值得的**。每当Java 平台有重要的发行时，都会发布一个网页来说明新的特性。这些网页值得好好读一读［Java8-feat, Java9-feat］ 。举个例子，假设想要编写一个程序，用它打印出命令行中指定的一条URL 的内容 (Linux 中 `curl` 命令的作用大体如此)。在Java 9之前，这些代码有点烦琐，但是Java 9 在 `InputStream` 中增加了 `transferTo` 方法。下面就是利用这个新方法完成这项任务的完整程序：

```java
// Printing the contents of a URL with transferTo, adde in Java9
public static void main(String[] args) throws IOException {
    try (InputStream in = new URL(args[0]).openStream()) {
        in.transferTo(System.out);
    }
}
```

这些标准类库太庞大了，以到于不可能学完所有的文档[Java9-api]，但是**每个程序员都应该熟悉 `java.lang` `java.util` `java.io` 及其子包中的内容**。关于其他类库的知识可以根据需要随时学习。总结类库中的机制超出了本条目的范围，几年来它们已经发展得十分庞大了。

其中有几个类库值得一提。Collections Framework （集合框架）和Stream 类库（详见第45条至第48 条）应该成为每一位程序员基本工具箱中的一部分，同样也应该成为`java.util.concurrent` 中并发机制的组成部分。这个包既包含高级的并发工具来简化多线程的编程任务，还包含低级别的并发基本类型，允许专家们自己编写更高级的井发抽象。关于 `Java.util.concurrent` 的高级部分，请参阅第80 条和第81 条。

在某些情况下，一个类库工具并不能满足你的需要。你的需求越是特殊，这种情形就越有可能发生。虽然你的第一个念头应该是使用标准类库，但是，如果你在观察了它们在某些领域所提供的功能之后，确定它不能满足需要，你就得使用其他的实现。任何一组类库所提供的功能总是难免会有遗漏。如果你在Java 类库中找不到所需要的功能，下一个选择应该是在高级的第三方类库中去寻找，比如Google 优秀的开源Guava 类库[Guava ] 。如果在所有相应的类库中都无法找到你所需的功能，就只能自己实现这些功能了。

总而言之，不要重复发明轮子。如果你要做的事情看起来是十分常见的，有可能类库中已经有某个类完成了这样的工作。如果确实是这样，就使用现成的；如果还不清楚是否存在这样的类，就去查一查。一般而言，类库的代码可能比你向己编写的代码更好一些，并且会随着时间的推移而不断改进。这并不是在质疑你作为一个程序员的能力。从经济角度的分析表明：类库代码受到的关注远远超过大多数普通程序员在同样的功能上所能给予的投入。

### 60. 如果需要精确的答案，请避免使用 float 和 double

`float` 和 `double` 类型主要是为了科学计算和工程计算而设计的。它们执行二进制浮，或运算（ binary floating-point arithmetic ），这是为了在广泛的数值范围上提供较为精确的快速近似计算而精心设计的。然而，它们并没有提供完全精确的结果，所以不应该被用于需要精确结果的场合。**`float` 和 `double` 类型尤其不适合用于货币计算**。国为要让一个 `float` 或 `double` 精确地表示 `0.1`  (或者 10 的任何其他负数次方值)是不可能的。

例如，假设你的口袋中有\$1.03 ，花掉了42 美分之后还剩下多少钱呢？下面这个很简单的程序片段试图回答这个问题：

`System.out.println(1.03 - 0.42);`

遗憾的是，它输出的结果是0. 6100000000000001 。这并不是个别的例子。假设你的口袋里有$1 ，你买了9 个垫圈，每个为10 美分那么应该找回多少零头呢？

`System.out.println(1.00 - 9 * 0.10);`

根据上述程序片段，你得到的是$0.09999999999999998 美分

你可能会认为，只要在打印之前将结果做一下舍人就可以解决这个问题，但遗憾的是，这种做法并不总是可行的。例如，假设你的口袋里有\$1 ，你看到货架上有一排美昧的糖果，标价分别为10美分 、20美分 、30美分 ，等等，一直到\$1 。你打算从标价为10美分 的糖果开始，每种买 1 颗，一直到不能支付货架上下一种价格的糖果为止，那么你可以买多少颗糖果？还会找回多少零头？下面是一个简单的程序，用来解决这个问题：

```java
// Broken - uses floating point for monetary calculation!
public static void main(String[] args) {
    double funds = 1.00;
    int itemsBought = 0;
    for (double price = 0.10; funds >= price; price+=0.10) {
        funds -= price;
        itemsBought++;
    }
    System.out.println(itemsBought + " items bought.");
    System.out.println("Change: $" + funds);
}
```

如果真正运行这个程序，你会发现可以支付3 颗糖果，并且还剩下$0.3999999999999999 。
这个答案是不正确的！解决这个问题的正确方法是使用`BigDecirnal` 、`int` 或者`long` 进行货币计算。

下面的程序是上一个程序的简单翻版，它使用`BigDecimal` 类型代替double 。注意，它使用了`BigDecimal` 的`String` 构造器，而不是用`double` 构造器。为了避免将不正确的值引入到计算中，这是必需的 [Bloch05, Puzzle 2] :

```java
public static void main(String[] args) {
    final BigDecimal TEN_CENTS = new BigDecimal(".10");
    
    int itemsBought = 0;
    BigDecimal funds = new BigDecimal("1.00");
    for (BigDecimal price = TEN_CENTS; funds.compareTo(price) >= 0; price = funds.subtract(price)) {
        funds = funds.subtract(price);
        itemsBought++;
    }
    System.out.println(itemsBought + " items bought.");
    System.out.println("Change: $" + funds);   
}
```

如果运行这个修改过的程序，会发现可以支付4 颗糖果，还剩下$0.00 。这才是正确的答案。

然而，使用 `BigDecimal` 有两个缺点：与使用基本运算类型相比，这样做很不方便，而且速度很慢。对于解决这样一个简单的问题，后一种缺点并不要紧， 但是前一种缺点可能会让你很不舒服。

除了使用`BigDecimal` 之外，还有一种办法是使用`int` 或者`long` ，到底选用 `int` 还是 `long` 要取决于所涉及数值的大小，同时要自己处理十进制小数点。在这个示例中，最明显的做法是以分为单位进行计算，而不是以元为单位。下面是这个例子的简单翻版，展示了这种做法：

```java
public static void main(String[] args) {
    int itemsBought = 0;
    int funds = 100;
    for (int price=10; funds>=price; price+=10) {
        funds -= price;
        itemsBought++;
    }
    System.out.println(itemsBought + " items bought.");
    System.out.println("Change: $" + funds);
}
```

总而言之，对于任何需要精确答案的计算任务，请不要使用`float` 或者 `double` 。如果你想让系统来处理十进制小数点，并且不介意因为不使用基本类型而带来的不便，就请使用`BigDecimal` 。使用`BigDecimal` 还有一些额外的好处，它允许你完全控制舍人，每当一个操作涉及舍入的时候，你都可以从8 种舍入模式中选择其－ 。如果你正通过合法强制的舍入行为进行商务计算，使用`BigDecimal` 是非常方便的。如果性能非常关键，并且你又不介意自己处理十进制小数点，而且所涉及的数值又不太大，就可以使用`int` 或者`long` 。如果数值范围没有超过9 位十进制数字，就可以使用`int` ；如果不超过18 位数字，就可以使用`long` 。如果数值可能超过18 位数字，就必须使用 `BigDecimal` 。



基本类型优先于装箱基本类型

如果其他类型更适合，则尽量避免使用字符串

了解字符串连接的性能

通过接口引用对象

接口优先于反射机制

谨慎地使用本地方法

谨慎地进行优化

遵守普遍接受的命名惯例
